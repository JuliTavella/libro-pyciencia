\chapter{Introducción a Python} \label{ch:intro}

\begin{wraptable}{r}{5cm}
\begin{modulesinfo}
\begin{center}
{\small
    \href{https://github.com/facundobatista/libro-pyciencia/tree/master/código/intro/}{Código disponible}
}
\end{center}
\end{modulesinfo}
\end{wraptable}

En este capítulo mostraremos las bases de Python. 

Haremos un recorrido por las distintas características del lenguaje, y luego mostraremos cómo ejecutar programas y usar el intérprete en modo interactivo. Luego haremos un repaso de los tipos de datos más usados, los controles de flujo que posee el programa (incluidas las excepciones, para manejo de error), y las distintas formas de encapsular código. Finalmente indicaremos las mejores formas de pedir ayuda.

Este contenido es imprescindible para entender lo suficiente de Python como para poder leer el resto del libro. Por supuesto, no es todo lo que se puede aprender de Python, solamente son las estructuras iniciales que permitirá arrancar con el lenguaje, utilizarlo para los primeros programas, y de allí escalar todo lo que se desee.


\section{¿Qué es Python?}\label{sec:que-es-python}

Python es un lenguaje de programación de muy alto nivel y multiparadigma.

Es un lenguaje maduro, ya que fue creado en diciembre de 1989 y usado por muchos años en todos los ámbitos posibles (desde electrodomésticos hasta en el espacio). Al mismo tiempo, es un lenguaje que no se quedó estancado, siempre está en constante evolución a través de mejoras permanentes que realiza la comunidad.

Porque es la comunidad la responsable del desarrollo y progreso del lenguaje, como así de sus herramientas relacionadas, conferencias y eventos alrededor del lenguaje. Hay grupos de desarrolladores y usuaries de Python alrededor de todo el mundo, pero el principal medio de comunicación y coordinación es online.

La comunidad es uno de los puntos fuertes de Python, ya que no sólo ofrece la capacidad técnica de mantener y evolucionar el lenguaje, o administrativa de realizar eventos, sino que provee una estructura social que cobija a les desarrolladores recién llegades lenguaje, pero no sólo al principio, sino que es una red que facilita el aprendizaje y el perfeccionamiento a lo largo de toda la vida.

\begin{info}
¿Qué es una P.E.P.? 

Es una Propuesta de Mejora de Python (Python Enhancement Proposal, en inglés), un documento que reúne las razones, ideas, discusiones de la comunidad, conclusiones, y todos los detalles relevantes con respecto a cambios grandes en el lenguaje, la biblioteca estándar, o el proyecto en general. El punto de entrada para explorarlas es la PEP 0 \cite{pep0}.
\end{info}

Esta misma comunidad es la que garantiza soporte y ayuda, ya que Python no depende de una empresa y no corre el riesgo de estancarse porque no es más prioridad para esa empresa (o directamente no poder usarlo más en caso de conflictos legales por copyright). A este respecto cabe mencionar a la Python Software Foundation \cite{psf}, una organización sin fines de lucro encargada de proteger el copyright de Python, garantizando su libertad y disponibilidad.

Volviendo a Python, es un lenguaje muy fácil de aprender, ya que por diseño posee una sintaxis muy sencilla, y todo el lenguaje está basado en estructuras conceptuales que se repiten todo el tiempo, bajando muchísimo la curva de adopción.

En parte por esto es que está tan recomendado para usarlo para enseñar informática, porque todo el impacto pedagógico se puede enfocar en algoritmos y lo que se quiera transmitir, sin tener que aprender primero el lenguaje en sí.

Lo mismo vemos reflejado en el mundo de la Ciencia, que fue adoptando Python en los últimos años de forma vertiginosa, ya que es un lenguaje que permite enfocarse en la ciencia a resolver y no es una traba en sí mismo.

\begin{figure}
    \includegraphics[width=400pt,keepaspectratio=true]{Chapters/intro/imgs/tiobe.png}
    \caption{Evolución de la adopción de Python en el mundo}
\end{figure}

Esta simplicidad se transmite en la cultura de Python, en conceptos como el de ``debería haber una, y preferiblemente solo una, manera obvia de hacerlo''. Esta y otras frases que forman el núcleo de la filosofía de Python son parte del Zen de Python \cite{zen-de-python} (que incluimos traducido en el apéndice \ref{ap:zen-de-python}), una serie de indicaciones generales para pensar sobre nuestros desarrollos y para enfocar el intercambio de ideas alrededor de un pedazo de código, no reglas duras que haya que cumplir a rajatabla.

El término ``pitónico'' (o pythónico, o pythonic en inglés) es un neologismo común en la comunidad de Python, que expresa varios conceptos aplicados al estilo del programa. Decir que un código es pitónico es decir que usa correctamente los idiomas de Python, que se adapta a la filosofía minimalista de Python, y hace énfasis en su legibilidad, entre otros aspectos. Por el contrario, si el código es difícil de entender, trabado, o aplica idiomas traídos de otros lenguajes (con estructuras que normalmente se pueden resolver de forma más sencilla en Python), se lo denomina ``no pitónico'' (unpythonic).

\begin{info}
El nombre Python proviene del grupo comediante británico que tuvo su auge en los años 1960 y 1970, no por la serpiente, aunque esta se utilice en tantas imágenes y logos.
\end{info}

Por último, y no menos importante, es gratis, libre, y de código abierto. Tiene una licencia muy relajada, por lo cual podemos usar Python de forma segura tanto en ámbitos estatales como privados, sin necesitar consultar con ningún abogado primero :). La única restricción que tiene a este respecto es si quisiéramos distribuir Python nosotros mismos, nada más.


\subsection{Propiedades del lenguaje}\label{intro--propiedades-del-lenguaje}

Python es al mismo tiempo de tipado dinámico y de tipado fuerte. Dinámico, porque no hace falta declarar los nombres antes de utilizarlos. Fuerte, porque se respeta el tipo de los objetos y no se realizan conversiones implícitas. Habiendo dicho eso, tenemos que tener en cuenta que las definiciones más estrictas sobre \textit{tipado} son sobre lenguajes que utilizan ``variables'', y Python no posee variables como tales, sino que son todos objetos y nombres para referenciar esos objetos (más detalle sobre este tema en la sección \ref{sub:pensando-pythonista}).

Posee una administración dinámica de la memoria, usando una combinación de conteo de referencias y \textit{garbage collector} (``recolector de basura'', en castellano, pero se acostumbra mencionarlo en inglés) para referencias cíclicas. Por lo tanto, aunque hay mecanismos para tener mayor o menor control de lo que sucede en memoria, en general no nos tenemos que preocupar de la misma.

Cómo mencionamos en la introducción, Python es multiparadigma. Esto implica que aunque en Python todos son objetos, nosotros podemos programar completamente de forma estructurada, e incluso utilizar muchas características y módulos que vienen de la programación funcional u orientada a aspectos. Resaltamos esta versatilidad en su aspecto pedagógico, porque normalmente se aprende programación estructurada primero y el pasaje a la programación orientada a objetos no es para nada trivial, entonces poder utilizar un lenguaje que permite empezar estructurado, e incluir eventualmente la creación de clases propias, mientras estamos expuestos a objetos todo el tiempo, hace que la curva de aprendizaje de la programación orientada a objetos sea gradual.

También en la introducción mencionamos que es un lenguaje de alto nivel. Esto es porque posee muchas estructuras de alto nivel y modernas. Resaltamos los conjuntos y diccionarios como tipos de datos integrados, funciones y clases como ciudadanos de primer orden (o sea, son simplemente objetos), módulos y paquetes para estructurar código, iteradores y generadores muy bien integrados al lenguaje, etc. Y posee un manejo moderno de errores a través de excepciones.

Aunque solemos decir simplemente que Python es un lenguaje interpretado, realmente tiene un paso de compilación interno. En detalle, la ejecución de un programa en Python se realiza en dos pasos a partir del código fuente que le pasamos: primero Python compila ese código a una series de instrucciones de la máquina virtual de Python, y luego procede a ejecutar esas instrucciones (que conmunmente denominamos \textit{bytecode}. Esto es similar a otros lenguajes (como Java, VisualBasic, o COBOL, por ejemplo) con la diferencia fundamental que el proceso es automático: no hay intervención humana entre el primer paso de compilación y el segundo de ejecución en la máquina virtual.

Un factor clave en la velocidad de desarrollo es el intérprete interactivo, una herramienta que nos permite ejecutar pequeñas muestras de código sin tener que incluirlas en un programa propiamente dicho, facilitando al mismo tiempo una exploración de los objetos con los que estemos interactuando. Realizando esta exploración y experimentación en el intérprete interactivo, de forma rápida y sencilla, se logra incorporar al código esos algoritmos o líneas de código ya probadas y estables, reduciendo notablemente el ciclo de prueba y error.

Las distintas funcionalidades y herramientas de Python no están integradas todas en su núcleo, sólo algunas forman parte de Python en sí, y el resto están disponibles a través de módulos y paquetes. Una gran cantidad de módulos están disponibles siempre que tengamos Python instalado en el sistema: son aquellos que forman parte de la llamada Biblioteca Estándar. Esta biblioteca es tan variada y extensa que generó la frase ``Python viene con las pilas incluidas'', ya que gran parte del desarrollo día a día se puede realizar sin echar mano a módulos externos.

Y también es portable, ya que corre en muchas plataformas. Y no estamos hablando solamente de las tres principales (Linux, Windows y MacOS) sino también las derivadas de Unix (como FreeBSD, o Solaris) y algunas más inusuales como Cygwin o AIX.


\subsection{Biblioteca estándar y módulos externos}\label{intro--stdlib-y-modulos}

Cómo decíamos arriba, parte de la funcionalidad está integrada en Python como lenguaje, y luego tenemos la biblioteca estándar con gran cantidad de módulos y paquetes. Pero también existen módulos y paquetes de terceros. En esta sección vamos a formalizar esos conceptos, y a echar luz sobre cómo aprovechar estas funcionalidades.

Podemos pensar que tenemos tres anillos concéntricos de funcionalidad. Desde lo más cercano y fácilmente utilizable, hasta lo más lejano y con más preparación necesaria para ser aprovechada.

Empecemos por lo más cercano.

\subsubsection{Integrada en Python}\label{intro--modulos-builtin}

También denominada \textit{builtin}, es la funcionalidad que está adentro de Python mismo como intérprete del lenguaje. Podemos separarla por un lado en aquella que tenemos a disposición por la sintaxis y semánticas mismas del lenguaje, y por el otro en la gran cantidad de objetos que podemos utilizar directamente.

La sintaxis y semántica del lenguaje en sí se encuentra detalladas en la Referencia del Lenguage \cite{reflenguaje}, una sección de la documentación pensada para entender cómo funciona realmente el lenguaje y sus estructuras internas. Si estamos arrancando con Python no hace falta que nos involucremos con estos documentos ahora, pero es un paso obligado cuando el conocimiento del lenguaje se profundiza.

\begin{info}
Python realmente no es un lenguaje, es la especificación de un lenguaje. La implementación de esa especificación más conocida es la que está escrita en C (a la que llamamos cPython cuando queremos marcar esa diferencia). Otras implementaciones son Jython (un Python escrito en Java), IronPython (en C\#), MicroPython (que corre nativo en algunos microcontroladores), y notablemente PyPy, un Python escrito... ¡en Python!
\end{info}

Un ejemplo de funcionalidad parte del lenguaje mismo es la capacidad de poder llamar a una función con una cantidad variable de argumentos.

Por otro lado, los objetos que tenemos disponibles para utilizar directamente por estar integrados en el lenguaje están documentados al principio de la Referencia de la Biblioteca Estándar \cite{stdlib}, agrupados en funciones, algunas constantes, tipos de datos y excepciones.

Como ejemplos de esto último podemos mencionar la función \mip{len}, que nos permite saber el largo de una estructura, o el tipo de dato \mip{int}, para representar enteros.


\subsubsection{Parte de la Biblioteca Estándar}\label{intro--modulos-stdlib}

El resto de la Referencia de la Biblioteca Estándar \cite{stdlib} versa sobre aquella funcionalidad externa al intérprete de Python en sí mismo, pero disponible en cualquier instalación de Python.

Está agrupada en distintos módulos, y para acceder a ella debemos importar esos módulos (más detalle sobre módulos y paquetes en \ref{sub:modulos}).

Por ejemplo, para calcular el factorial de un número, podemos usar la función \mip{factorial} del módulo \mip{math}, que es el que debemos importar primero.


\subsubsection{El resto del mundo}\label{intro--modulos-resto}

Si queremos funcionalidad de terceros, que no está integrada a Python o en la biblioteca estándar, siempre podemos instalar módulos disponibles en Internet.

La forma más sencilla y directa de hacer esto es utilizar el programa \texttt{pip}, que automáticamente descarga lo que indiquemos del Índice de Paquetes de Python (en inglés Python Package Index, al que normalmente conocemos como PyPI) y luego lo instala en nuestro sistema o algún entorno en particular.

\begin{info}
Hay una convención para nombrar PyPI y separarlo de PyPy (el Python hecho en Python): PyPI lo nombramos ``pai-pi-ai'', y a PyPy ``pai-pai''.
\end{info}

Por supuesto, también podemos utilizar el administrador de paquetes de nuestro sistema (como \texttt{apt} en Debian/Ubuntu), utilizar pip para instalar paquetes provenientes de otros repositorios (como Github) o directamente podemos descargar los paquetes necesarios a mano e instalarlos.

A lo largo del libro iremos utilizando varios paquetes que se necesitan instalar de esta forma, los cuales estarán detallados al principio de cada capítulo. También vale la pena repasar el capítulo donde mostramos más en detalle las distintas alternativas para instalar paquetes \ref{ch:entornos}.



\section{Editando, corriendo, e interpretando}

En esta sección veremos cómo hacer nuestro primer programa en Python. Algo sencillo, pero que nos permitirá explorar distintas formas de editarlo y ejecutarlo, y otros conceptos aledaños.


\subsection{Editando y ejecutando Python}

Mencionamos arriba que podemos considerar que Python es interpretado, pero realmente es compilado. A fines prácticos, especialmente al arrancar, podemos considerar efectivamente que es interpretado: nosotros le pasamos el código fuente, y Python \textit{lo ejecuta}.

¡Probemos eso! Agarremos cualquier editor (más adelante profundizamos ahí) y escribamos un programita muy simple, y lo grabamos en un archivo \texttt{hola.py}:

\pyfile{Chapters/intro/code/holamundo.py}

Luego, en una terminal ejecutamos nuestro programa...

\begin{verbatim}
$ python3 hola.py
¡Hola mundo!
\end{verbatim}

Es así de simple. Grabamos el archivo, lo ejecutamos, tenemos el resultado. Si queremos realizar modificaciones al archivo, volvemos a grabar, volvemos a ejecutar. Nada más. Este ``ciclo corto'' hace que iterar sobre la construcción de un programa sea muy eficiente en Python.

Por otro lado, ¿qué es eso de ir a la terminal para ejecutar un programa? Bueno, tenemos principalmente dos tipos de programas, con y sin interfaz gráfica. El que mostramos arriba no posee una interfaz gráfica, entonces lo usamos desde la terminal. 

Si nuestro programa fuese de interfaz gráfica, podríamos ir y hacerle doble-click al programa y que se ejecute. En realidad también lo podemos hacer en un programa sin interfaz gráfica, pero todo lo que veríamos es una terminal que nuestro sistema abriría para ejecutar el programa, que se cerraría cuando este termine (y si el programa termina rápidamente, como el ejemplo de arriba, veríamos sólo un parpadeo).

Más adelante nos encargaremos de hacer programas con interfaz gráfica (ver Capítulo \ref{ch:guis}), pero por ahora enfoquémosnos en saber al menos cómo ejecutar cualquier tipo de programa: desde la terminal.

Obviamente para ejecutar nuestro programa con Python necesitamos a Python instalado en nuestro sistema. Lo vamos a encontrar ya instalado en cualquier Linux o MacOS, pero vamos a necesitar instalarlo en Windows. En cualquier caso, todas las versiones para todos los sistemas están en la página oficial de descargas \cite{pydownloads}. 

Como mostramos arriba, siempre podemos pasarle nuestro programa al intérprete de Python para que lo ejecute. Si queremos poder ejecutarlo directamente, quizás tengamos que realizar una acción extra, dependiendo de nuestro sistema. En Windows, el instalador mismo de Python asocia la extensión \texttt{.py} al intérprete de Python, entonces no necesitamos hacer nada. 

En Linux y MacOS, por otro lado, tenemos que hacer que nuestro programa sea ejecutable e indicar en el mismo programa que debe ejecutarse con Python. Veamos esto en detalle. Primero modificamos el programa, agregando una linea muy particular al principio y luego una linea en blanco:

\pyfile{Chapters/intro/code/holamundo2.py}

Esa linea particular del principio tiene una estructura muy específica: arranca con estos dos caracteres \verb|#!| (llamados \textit{shebang}) que indican que a continuación está el programa que va a interpretar las líneas del archivo, \texttt{python3} en nuestro caso.

Luego hacemos ejecutable al programa, y lo corremos directamente:

\begin{verbatim}
$ chmod +x hola.py
$ ./hola.py 
¡Hola mundo!
\end{verbatim}


\subsection{Editando Python}

Python tiene una sintaxis tan sencilla y limpia que no se necesita demasiada ayuda del editor que estemos usando para escribir código. 

Entonces, cualquier editor de texto que sea útil para escribir programas (NO Microsoft Word, por ejemplo) nos es suficiente. Ejemplos de este tipo son Vim, Emacs, Kate, Textmate o Notepad++.

Habiendo dicho eso, igualmente mucha gente prefiere desarrollar utilizando Entornos de Desarrollo Integrados (en inglés, \textit{Integrated Development Environment}, lo que forma la sigla ``IDE'' que es la que se usa normalmente también en castellano). Esto es porque un IDE integra el editor (simple, como decíamos) con un navegador de archivos, herramientas de debugging, un interprete interactivo, y muchas funcionalidades más. Ejemplos de IDEs son PyCharm, VisualStudio, o Spyder.

Esas funcionalidades extras que proveen los IDEs son tan útiles que incluso se han ido montando herramientas sobre los editores simples para obtener algunas de ellas. Quizás el ejemplo más famoso de eso es la configuración de Fisa para Vim \cite{fisavim}.

En cualquier caso, usar un editor simple más bien pelado o un IDE súper completo (o cualquier intermedio entre esos dos extremos) no deja de ser una elección personal. Nuestra recomendación es que las personas nuevas a la programación no se traben demasiado en arrancar con la herramienta ideal, que elijan una más o menos rápido y se pongan a programar, la elección del editor o IDE ideal para esa persona irá decantando con el tiempo.

Para elegir con qué arrancar siempre es bueno revisar la página de Python Argentina dedicada a editores e IDEs \cite{pyar_ides}.


\subsection{Usando módulos}\label{sub:intromods}

Un concepto básico que necesitamos para arrancar es cómo utilizar los módulos que Python trae en la Biblioteca Estándar. Porque el programa que hicimos arriba usa la función integrada \mip{print} pero enseguida vamos a tener que empezar a utilizar otras funciones no integradas.

Para usar un módulo primero tenemos que importarlo. La forma más directa de hacer esto es a través de la declaración \mip{import}, y luego podremos acceder a los contenidos del módulo a través de la ``notación punto'' (este es uno de esos conceptos genéricos del lenguaje: siempre que queramos acceder a algo que está adentro de un objeto, podemos usar el punto: \mip{.}.

Veamos un simple ejemplo. 

\pyfile{Chapters/intro/code/raiz.py}

Ahí vemos que importamos el módulo \mip{math} y luego llamamos a la función que nos calcula la raíz cuadrada usando el ``punto'': \mip{math.sqrt(2)}.

Más detalles sobre módulos y distintas formas de importarlos y usarlos en \ref{sub:modulos}.


\subsection{El intérprete interactivo}

En realidad no tenemos que escribir todo un programa para probar algo en Python. Uno de las mejores características del lenguaje es traer incorporado un intérprete interactivo.

Si ejecutamos \texttt{python3} sin pasarle ningún programa, Python automáticamente abrirá el intérprete interactivo, mostrándonos un \textit{prompt} y esperando que escribamos algo:

\begin{verbatim}
$ python3
Python 3.8.2 (default, Jul 16 2020, 14:00:26) 
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
\end{verbatim}

Obviamente las primeras líneas pueden variar en función de la versión de Python que tengamos instalada, pero lo importante es ese \texttt{\textgreater\textgreater\textgreater} que nos habilita a empezar a escribir.

Llamamos ``interactivo'' a este modo del intérprete, porque Python compilará y ejecutará cada linea que escribamos, sin necesidad de otros pasos. 

A lo largo de este libro veremos muchísimos ejemplos de código que son realizados directamente en el intérprete interactivo, y justamente nos podemos dar cuenta de eso por el prompt. Por ejemplo, reveamos como importar y usar un módulo, pero sin tener que escribir un programa para ello:

\begin{py}
>>> import math
>>> print(math.sqrt(2))
1.4142135623730951
\end{py}

Vemos que la linea posterior al \mip{import} es directamente el prompt donde escribimos el \mip{print}: esto es porque Python no tiene nada que mostrarnos en el medio. Luego, como hacemos un \mip{print}, la salida correspondiente la vemos directamente allí.

En realidad no es necesario hacer un \mip{print} para ver un resultado en el intérprete interactivo, ya que este luego de ejecutar cada linea nos mostrará abajo el objeto resultado de esa linea, a menos que sea \mip{None}.

\begin{info}
\mip{None} es el equivalente de Python al más conocido NULL en otros sistemas. No es ni verdadero ni falso (aunque a nivel booleano evalúa a falso), no es vacío, ni cero. Es \textit{la nada}. La ausencia de algo. Es \mip{None}.
\end{info}

Esto nos permite usar el intérprete de forma muy sencilla para explorar distintos comportamientos..

\begin{py}
>>> 2 + 3
5
>>> len("hola")
4
\end{py}

Hay una diferencia significativa, sin embargo, entre la salida de \mip{print} y lo que nos muestra el intérprete interactivo en cada resultado. Para construir la salida (convertir el objeto resultado a una representación textual a mostrar en la terminal) el \mip{print} utiliza la función integrada \mip{str}, que nos deja la representación más ``simple y humana'' del objeto, mientras que el intérprete interactivo usa la función integrada \mip{repr}, que apunta a lograr la representación más ``exacta'' del objeto.

Vemos en el siguiente ejemplo como con el \mip{print} corremos el riesgo de confundir el tipo de dato del resultado (¡parece un número!), mientras que con el \mip{repr} es evidente que es una cadena de texto:

\begin{py}
>>> print("23")
23
>>> "23"
'23'
\end{py}

En realidad el intérprete interactivo procesa la linea que acabamos de escribir cuando esa linea termina, lo que nos lleva a marcar la diferencia entre líneas lógicas y líneas reales: el intérprete interactivo se da cuenta cuando la linea todavía no terminó (aunque hayamos apretado ENTER) porque falta cerrarla lógicamente. Veamos un ejemplo de eso, donde la linea continúa porque falta cerrar el paréntesis del \mip{print}, y veamos como el intérprete nos marca esa ``línea continuación'' con tres puntos abajo del prompt:

\begin{py}
>>> print("Hola",
... 123)
Hola 123
\end{py}


\subsection{Jupyter Notebook}

El intérprete interactivo que trae Python por default no es el único que existe, sino que tenemos a disposición múltiples alternativas, especializadas para distintos fines.

Quizás el intérprete alternativo más popularizado es IPython \cite{ipython}, un shell interactivo que añade funcionalidades extras al intérprete interactivo incluido en Python, como resaltado de líneas y errores mediante colores, una sintaxis adicional para el shell, etc.

La funcionalidad núcleo de IPython fue evolucionando en el tiempo y se convirtió en una aplicación web llamada Jupyter Notebook. Por su baja barrera de entrada para interactuar con el mismo, soporte para integrar textos y gráficos entre las celdas de ejecución, y facilidad para la distribución del contenido, Jupyter Notebook se ha vuelto el intérprete interactivo de facto en el ámbito científico.

En las próximas secciones utilizaremos casi exclusivamente Jupyter Notebooks para los ejemplos mostrados en el libros (y en todos casos haremos referencia al notebook real, accesible en internet, para que puedan descargarlo, modificarlo y jugar con los ejemplos, que es una muy buena manera de aprender).


\subsection{Explorando}

Tanto el intérprete interactivo como Jupyter Notebook nos permite explorar el lenguaje y sus comportamientos. Esto es especialmente evidente si utilizamos las funciones integradas \mip{dir} y \mip{help}, que nos permiten ver los interiores de un objeto y directamente pedir ayuda en la terminal y ver su documentación.

En el siguiente ejemplo vemos como podemos descubrir qué atributos tiene el tipo de dato \mip{list} y pedir ayuda sobre uno de ellos.

\begin{py}  
>>> dir([])
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', 
'__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', 
'__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', 
'__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', 
'__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', 
'__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 
'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 
'remove', 'reverse', 'sort']
>>> help([].count)

Help on built-in function count:

count(value, /) method of builtins.list instance
    Return number of occurrences of value.
\end{py}

Siempre que miremos dentro de los distintos objetos vamos a encontrar muchos atributos que empiezan y terminan con doble guión bajo. Estos son métodos especiales que permiten a los objetos integrarse y utilizar la sintaxis y semántica del lenguaje en sí (ya sean estos objetos integrados en Python, creados por nosotros o por terceros. Mientras estemos aprendiendo Python podemos ignorarlos tranquilamente, dejándolos para cuando avancemos con el lenguaje. Habiendo dicho eso, durante el libro mencionaremos y utilizaremos algunos, que explicaremos oportunamente.

\begin{info}
Es difícil y cansador decir, por ejemplo para referirse al \mip{__len__}, ``doble guión bajo len doble guión bajo'', o su equivalente en inglés ``double underscore len double underscore'', por eso se creó una forma especial para nombrarlos: usando ``dunder'' (que es una especie de abreviatura del double underscore en inglés), con lo que para el ejemplo nos quedaría ``dunder len''.
\end{info}


\section{Tipos de datos}

En esta sección mostraremos los tipos de datos más utilizados en Python.

No incluiremos \textit{todos} los tipos de datos integrados en el lenguaje (ni mucho menos todos los presentes en la Biblioteca Estándar), sólo haremos foco en aquellos más utilizados y que les permitirá comenzar y realizar gran parte de todo lo que harán con Python.

\subsection{Números}\label{sub:numeros}

Comenzamos con el tipo de datos más básico en todos los lenguajes: los números enteros, cuyo tipo de datos es \mip{int}.

Las operaciones básicas son las mismas que en cualquier otro lado y no tenemos ninguna sorpresa, con los únicos detalles a destacar que la división de números enteros da un \mip{float} (el punto flotante binario, que veremos a continuación), y que el operador para la exponenciación es \mip{**}.

\jupynotex[1-5]{Chapters/intro/code/tipos-nums.ipynb}

Complementando la división, Python incluye un operador para la división con el resultado truncado, y el módulo, e incluso una función integrada que da ambos resultados al mismo tiempo:

\jupynotex[6-8]{Chapters/intro/code/tipos-nums.ipynb}

Más allá de estas operaciones particulares, el rasgo más relevante a destacar en los enteros de Python es que no tienen límite (porque no están atados a ninguna representación en particular), entonces no hace falta que nos preocupemos por ese detalle:

\jupynotex[9]{Chapters/intro/code/tipos-nums.ipynb}

Los números enteros en Python también funcionan como secuencias de bits, y más allá que usemos la representación decimal para expresarlos, o en binario, o en hexadecimal, simplemente son números enteros. Escribirlos en otras bases es sencillo, y para verlos en esas representaciones tenemos funciones integradas:

\jupynotex[10-13]{Chapters/intro/code/tipos-nums.ipynb}

Python tiene operadores para trabajar con los enteros como secuencias de bits: el ``and'' (\mip{&}), el ``or'' (\mip{|}), el ``xor'' (\mip{^}), y los ``shift'' a izquierda y derecha (\mip{<<} y \mip{>>}).

\jupynotex[14-18]{Chapters/intro/code/tipos-nums.ipynb}

El punto flotante binario (\mip{float}) de Python, por otro lado, es exactamente el punto flotante ejecutado en el procesador, y tiene el mismo comportamiento que en los otros lenguajes:

\jupynotex[19-22]{Chapters/intro/code/tipos-nums.ipynb}

Así y todo siendo uno de los tipos de datos más utilizados en todos los lenguajes, hay ciertas trampas del punto flotante binario que es imperioso conocer, y a los que les dedicamos un capítulo separado en \ref{ch:float}.

Uno de esos detalles es que no debemos utilizar \mip{float} para manejar dinero. De esa limitación nació la implementación del punto flotante decimal, que podemos encontrar en el módulo \mip{decimal} de la Biblioteca Estándar.

\jupynotex[23-25]{Chapters/intro/code/tipos-nums.ipynb}

\begin{info}
La forma \texttt{from ... import ...} nos permite importar el módulo y usar sus objetos directamente, sin tener que luego repetir el nombre del módulo todas las veces. Más detalles en \ref{sub:modulos}.
\end{info}

Como vemos en el ejemplo, no es lo mismo construir el Decimal a partir de la representación textual de un número ``con coma'' que de un \mip{float}; volvemos a hacer referencia al capítulo \ref{ch:float} donde nos adentramos en estos detalles.

Relacionado, tenemos la posibilidad de directamente utilizar fracciones si así fuese necesario, a través del módulo \mip{fractions}:

\jupynotex[26-28]{Chapters/intro/code/tipos-nums.ipynb}

Finalmente, debemos mencionar el tipo de datos \mip{complex}, integrado en el lenguaje, para manejar números complejos. En verdad tenemos soporte en la sintaxis para números imaginarios (agregándoles una \texttt{j} al final), y con ello armamos los complejos directamente:

\jupynotex[29-33]{Chapters/intro/code/tipos-nums.ipynb}

Las clases de cada tipo de dato funcionan como constructores y al mismo tiempo como conversores entre ellos mismos:

\jupynotex[34-36]{Chapters/intro/code/tipos-nums.ipynb}


\subsection{Cadenas}\label{sub:cadenas}

Las cadenas constituyen otro de los tipos de datos básicos que están presentes en infinidad de lenguajes. En Python no tienen nada de especial a primera vista, pero vamos a ir explorando algunas particularidades más adelante.

Por lo pronto hagamos la definición formal: las cadenas en Python son secuencias de caracteres Unicode delimitadas por comillas dobles o simples indistintamente.

En el siguiente ejemplo vemos casos de uno y otro delimitador, especialmente para el caso donde necesitamos usar uno de ellos como carácter dentro de la cadena:

\jupynotex[1-3]{Chapters/intro/code/tipos-cads.ipynb}

También como en tantos otros lenguajes, la barra invertida tiene el propósito de escapar ciertos caracteres especiales (y es un último recurso para usar los delimitadores dentro de la cadena). Hay que tener en cuenta siempre que la barra invertida sirve para escaparse a sí misma, y que los caracteres especiales suelen mostrarse distinto en el modo \mip{str} (representación más humana) que en el modo \mip{repr} (representación más exacta):

\jupynotex[4-9]{Chapters/intro/code/tipos-cads.ipynb}

Python tiene otro delimitador para cadenas: la triple comilla (ya sea doble o simple), que nos permite escribir una cadena a través de múltiples líneas:

\jupynotex[10-11]{Chapters/intro/code/tipos-cads.ipynb}

Las operaciones básicas a realizar sobre las cadenas están integradas en el lenguaje: saber el largo, concatenar y repetir:

\jupynotex[12-14]{Chapters/intro/code/tipos-cads.ipynb}

Las cadenas tienen también muchos métodos para trabajar con las mismas, veamos algunos de ellos (¡sólo ejemplos! les recomendamos revisar todos los métodos en \cite{stdlib_str}, ya que son muy útiles en el día a día):

\jupynotex[15-19]{Chapters/intro/code/tipos-cads.ipynb}

Un método en particular de gran utilidad es el \mip{format}, que permite armar cadenas reemplazando valores, lo cual es mucho más legible y ofrece más control que andar concatenando cadenas individuales. Más allá de estos ejemplos puntuales que mencionamos a continuación, el sistema de formateo en cuestión es muy poderoso, y vale la pena al menos sobrevolar la documentación \cite{stdlib_format}.

\jupynotex[20-21]{Chapters/intro/code/tipos-cads.ipynb}

Notablemente, no mencionamos ningún método para acceder a un carácter de la cadena, o a una subcadena de la misma. Esto se debe a que dicha funcionalidad está integrada en el lenguaje y es la misma para todas las secuencias.

La forma de acceder a un carácter de la secuencia es con los corchetes, escribiendo directamente la posición:

\jupynotex[22-24]{Chapters/intro/code/tipos-cads.ipynb}

En el ejemplo vemos que la primer posición de la secuencia es la número 0, y que si utilizamos números negativos se empieza a contar desde el final (lo cual es muy práctico, porque no hay que calcular la posición que queremos restándole algo al largo de la cadena).

Para subcadenas es también con corchetes, pero usamos dos valores, desde y hasta (con valores por defecto ``desde el principio'' o ``hasta el final'' si no se incorporan), y también soporta valores negativos, como indicábamos arriba:

\jupynotex[25-28]{Chapters/intro/code/tipos-cads.ipynb}

Esta operación de tomar la subcadena de una cadena en inglés se llama \textit{slicing}, y en general usamos ese término también en castellano (porque \textit{rebanar} cadenas nunca terminó prendiendo). 

Entender qué carácter se accede por posición es sencillo (sólo tenemos que acordarnos contar desde 0), pero en el caso de los slices es más difícil, hasta que nos acostumbramos. Una buena regla mnemotécnica es pensar que también arranca desde 0, pero lo que se cuentan son las ``separaciones entre las letras''. Más allá de cómo nos acordemos, la regla que tiene Python para numerar en los slices tiene dos propiedades muy útiles: por un lado si hacemos \mip{cad[x:y]} con valores positivos el largo de la subcadena va a ser \mip{y - x}, y por el otro es sencillo separar una cadena en dos, porque se usa el mismo número, o sea que \mip{cad[:x] + cad[x:]} nos termina dando la misma \mip{cad}.

También como todas las secuencias, si queremos tomar elementos de la misma pero con un determinado paso, podemos utilizar un tercer valor entre los corchetes:

\jupynotex[29]{Chapters/intro/code/tipos-cads.ipynb}

En el ejemplo usamos varias propiedades al mismo tiempo. Por un lado el \textit{desde} lo dejamos en blanco, para que tome el inicio por default, luego el \textit{hasta} lo usamos negativo porque nos interesaba obviar el \textit{newline} del extremo derecho, y finalmente el tercer valor, el paso, en dos, para ir agarrando cada dos caracteres.

Como con los números, podemos usar el constructor \mip{str} de la cadena para convertir desde otros tipos de datos (así como podemos también usar los constructores de números para pasar de cadenas a enteros o flotantes):

\jupynotex[30-33]{Chapters/intro/code/tipos-cads.ipynb}

Cuando mencionamos que los delimitadores de las cadenas eran la comilla doble, o simple, o sus variantes ``triple'', evitamos mencionar que en todos estos casos se puede poner un prefijo para cambiar el tipo de cadena definida. Por default si no especificamos nada (o si usamos la letra \textit{u}, por compatibilidad con versiones viejas de Python), la cadena será de tipo Unicode, lo que implica que será una secuencia de caracteres Unicode, con lo cual podemos escribir caracteres con acento, o en otros idiomas:

\jupynotex[34-36]{Chapters/intro/code/tipos-cads.ipynb}

Tengamos en cuenta que considerar a los caracteres como Unicode, más allá de su posible representación como bytes, nos permite trabajar con herramientas de transformación de texto sin mayor inconveniente:

\jupynotex[37-38]{Chapters/intro/code/tipos-cads.ipynb}

Si necesitamos trabajar con bytes directamente, podemos tener cadenas de bytes (donde no es más una secuencia de caracteres, sino una secuencia de bytes) si prefijamos la cadena con la letra \textit{b}. En estos casos es muy útil la notación \mip{\x} para ingresar el valor del byte en hexadecimal, como mostramos en el siguiente ejemplo:

\jupynotex[39-41]{Chapters/intro/code/tipos-cads.ipynb}

Es importante entender esta distinción no sólo porque las cadenas de bytes eran el default en versiones viejas de Python (y nos podemos cruzar con algún código así) sino también porque eventualmente necesitaremos convertir las cadenas Unicode a cadenas de bytes, ya que es la única manera de mandar cadenas a través de la red o grabarlas en disco.

Estas conversiones las hacemos con los métodos \mip{encode} y \mip{decode}. Aunque en el siguiente ejemplo parece simple, el tema de convertir de un lado para el otro le trae muchos dolores de cabeza a la mayoría de los programadores (más allá del lenguaje en que programen); les recomendamos que si quieren adentrarse en el tema vean esta charla por uno de los autores del libro \cite{entendiendo_unicode}.

\jupynotex[42-44]{Chapters/intro/code/tipos-cads.ipynb}

Otro tipo de cadena usada frecuentemente es la de tipo \textit{raw} (término que usamos en inglés, porque decir que son ``sin procesar'' o ``crudas'' es raro), donde la diferencia con las cadenas comunes es que la barra invertida NO funciona como carácter de escape (lo cual es especialmente útil al escribir expresiones regulares, tema que por respeto a les lectores NO tocaremos en el libro), sino que es tratada como un carácter normal:

\jupynotex[45-46]{Chapters/intro/code/tipos-cads.ipynb}

Finalmente, en las versiones más modernas de Python tenemos un tipo de cadena que se formatea automáticamente con las variables del entorno, sin tener que llamar explícitamente a \mip{format}, permitiendo incluso expresiones y algunos detalles más:

\jupynotex[47-48]{Chapters/intro/code/tipos-cads.ipynb}


\subsection{Listas}

Las listas son secuencias de objetos, se delimitan con corchetes, y cada objeto (sus elementos internos, que pueden ser cualquier cosa) se separan con comas.

Se acceden como cualquier secuencia, exactamente como vimos antes con las cadenas \ref{sub:cadenas}, e incluso tienen la misma forma de repetirlas o concatenarlas:

\jupynotex[1-6]{Chapters/intro/code/tipos-listas.ipynb}

La gran diferencia con las cadenas a nivel comportamiento (más allá que unas son secuencias de caracteres y las otras son secuencias de cualquier objeto Python) es que mientras las cadenas son ``inmutables'', las listas (como muchos otros tipos de datos) son ``mutables'', o sea que pueden cambiar.

El detalle fino de esto se explica un poco más adelante \ref{sub:pensando-pythonista}, pero veamos como para las listas efectivamente tenemos métodos que permiten modificarlas:

\jupynotex[7-9]{Chapters/intro/code/tipos-listas.ipynb}

¡Y no sólo agregarle elementos! También podemos reemplazar algún elemento o toda una parte:

\jupynotex[10-12]{Chapters/intro/code/tipos-listas.ipynb}

También podemos borrar elementos, no sólo con el método que nos permite especificar cual elemento en sí queremos borrar, sino también con la sentencia \mip{del}.

\jupynotex[13-15]{Chapters/intro/code/tipos-listas.ipynb}

\begin{info}
La sentencia \mip{del} es bastante especial en Python, ya que \textit{borra} elementos, lo cual nunca es trivial en un sistema que administra memoria automáticamente. En parte por eso no es una función (como \mip{len}), sino una sentencia, porque está muy integrada con el funcionamiento base del lenguaje.
\end{info}

Como en los otros casos, el constructor de las listas nos es bastante útil para crear listas a partir de otros objetos. \mip{list} construye una lista a partir de los elementos del iterable que reciba:

\jupynotex[13-16]{Chapters/intro/code/tipos-listas.ipynb}

\begin{info}
Un \textit{iterable} es cualquier objeto capaz de devolver sus elementos internos uno por vez, lo que nos permite iterarlos en un bucle for o para construir una lista, por ejemplo; una cadena es un iterable que devuelve caracteres, una lista es un iterable que devuelve sus objetos internos, etc.
\end{info}


\subsection{Tuplas}\label{sub:tuplas}

Las tuplas también son secuencias de objetos, y se definen separando estos elementos con coma (como en la definición de las listas), y opcionalmente rodeándolas con paréntesis, por claridad.

\jupynotex[1-5]{Chapters/intro/code/tipos-tuplas.ipynb}

Una diferencia fundamental con las listas es que las tuplas son inmutables, y en general una buena recomendación para decidir su uso en un caso u otro es entender si para los objetos internos es importante su cantidad y posición. Por ejemplo, la lista es mejor para guardar los archivos que hay en un directorio (más allá del orden en sí, el archivo no es más o menos archivo si está antes o después, y en el directorio podemos tener 0, 3, 27, 1000 archivos), en cambio la tupla es mejor para guardar coordenadas (si es en el plano vamos a tener siempre una tupla de dos elementos, ni uno ni tres, y es importante si un número está primero o segundo, ya que son ejes distintos).

En realidad la diferencia es aún más profunda: las tuplas forman parte del núcleo más central del lenguaje, ya que se usa en infinidad de detalles internos. Por ejemplo, si recordamos la función interna \mip{divmod} que explicamos cuando vimos números, veremos que esa función devuelve dos números... en verdad devuelve una tupla, que por otra característica de Python (``desempaquetado de tuplas'', que también tendemos a denominar en inglés como ``tuple unpacking'') podemos usar directamente como si fueran dos objetos:

\jupynotex[6-7]{Chapters/intro/code/tipos-tuplas.ipynb}

Obviamente necesitamos la misma cantidad de elementos en la izquierda y la derecha del igual, para que el ``desempaquetado'' funcione, aunque tenemos la posibilidad de usar un ``expansor'' para que tome múltiples argumentos:

\jupynotex[8-11]{Chapters/intro/code/tipos-tuplas.ipynb}

Una vez más, el constructor es la herramienta principal para convertir entre tipos:

\jupynotex[12-13]{Chapters/intro/code/tipos-tuplas.ipynb}


\subsection{Pensando como un pythonista}\label{sub:pensando-pythonista}

Hay una diferencia fundamental en cómo Python maneja los objetos internamente en la ejecución de un programa con respecto a otros lenguajes, y es imperativo entenderla porque nos explica mucho del funcionamiento del lenguaje.

Python no tiene \textit{variables}, y en consecuencia esas variables no tienen \textit{valores}. Estos son términos y conceptos que provienen de otros lenguajes de más bajo nivel (es decir, más cercanos al procesador), y no se aplican en Python. 

Python tiene \textit{objetos}, y usamos \textit{nombres} para hacer referencia a esos objetos. Es verdad que a veces por facilismo o sobresimplificación usamos las palabras ``variable'' y ``valor'' también cuando hablamos de un programa en Python o el funcionamiento del lenguaje, pero eso no nos tiene que confundir sobre el funcionamiento real.

Veamos la diferencia. Otros lenguajes, como C por ejemplo, sí poseen el concepto de \textit{variable}, como lugar donde se guarda un valor. Ese lugar es en memoria, y el valor que se guarda son los bits en esa posición de memoria.

\begin{center}
    \includegraphics[width=100pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-00.pdf}
\end{center}

En estos lenguajes es necesario declarar cómo se interpretan esos bits en esa posición de memoria. Por ejemplo, varios bytes seguidos pueden ser varias letras, o un número entero, e incluso podemos decirle al lenguaje que nos muestre esos bits de una manera u otra:

\begin{verbatim}
int a = 7303014;
printf("%i %s", a, (char *)&a);

  -->  7303014 foo
\end{verbatim}

En cambio, en Python no seguimos esa filosofía.

\begin{center}
    \includegraphics[width=100pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-01.pdf}
\end{center}

En Python manejamos directamente objetos. Estos objetos son de un tipo específico, y no pueden cambiar de tipo (``tipado fuerte''). Para referenciar esos objetos en memoria usamos nombres. 

\begin{center}
    \includegraphics[width=250pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-02.pdf}
\end{center}

Estos nombres pueden apuntar a uno u otro objeto, y no están asociados al tipo del objeto que vinculan. Entonces, no hace falta decir que el nombre \verb|a| va a ser un entero o una cadena, por ejemplo, porque el tipo pertenece al objeto que es nombrado. Cuando decimos que \mip{a = 3} sólo estamos creando un objeto en memoria de tipo entero (el 3) y a ese objeto lo estamos referenciando usando el nombre \verb|a|. 

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-03.pdf}
\end{center}

Si luego escribimos que \mip{a = "hola"}, estamos creando otro objeto en memoria, este de tipo cadena, con el valor \verb|"hola"|, y estamos usando el mismo nombre \verb|a| para referenciarlo. No es que \verb|a| haya cambiado de tipo, sólo apunta a otro objeto.

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-04.pdf}
\end{center}

Obviamente, como \verb|a| apunta al segundo objeto, ya no apunta al primero. Si ese objeto no es accesible desde ningún otro lado, para todo propósito nosotros podemos considerar que ya no existe (eventualmente Python lo eliminará y liberará memoria, pero esto es algo que podemos ignorar tranquilamente ya que Python administra la memoria por nosotros).

En los diagramas mostrados arriba vemos dos áreas diferentes. El grande es el espacio de objetos (a grandes rasgos lo que llamamos ``la memoria'', sin entrar en detalle cual sección de memoria en particular o cómo es manejada por Python). La columna de la izquierda, donde por ahora tenemos el nombre \verb|a|, es llamada ``espacio de nombres'', una sección en particular (de la memoria, obviamente, porque de última todo está en memoria, pero que no se nos mezcle con la otra parte genérica) donde guardamos los nombres, que son simplemente cadenas. En el espacio de nombres no podemos almacenar otra cosa que nombres, y estos nombres siempre apuntan a objetos ``en la memoria'' (no pueden apuntar a otros nombres en el espacio de nombres).

Python tiene un espacio de nombres ``global'', que está siempre disponible durante la ejecución del programa y accesible de cualquier lado, y va creando otros espacios de nombres en diferentes momentos y con una accesibilidad limitada. Por ejemplo, cuando se ejecuta una función esta tiene su propio ``espacio de nombres local'', diferente al global y diferente a los espacios de nombres de otras funciones, que es lo que permite que cada función pueda usar un mismo nombre apuntando a diferentes objetos y no entren en conflicto. 

En los diagramas, además de las dos secciones, y el nombre en una y el objeto en otra, vemos una flecha que va del nombre al objeto. Esta flecha representa justamente que ese nombre referencia a dicho objeto. Por eso cuando en Python escribimos \mip{a = "hola"} estamos realmente \textit{vinculando} el nombre \verb|a| con el ``objeto cadena con valor \verb|"hola"|'' (en inglés el verbo es ``bind'').

Retomemos el uso de estos diagramas mostrando los nombres y su vinculación a los objetos, y la diferencia fundamental entre objetos mutables e inmutables, que en conjunto son claves para entender cómo funciona Python internamente (para que eventualmente logremos ``pensar como un Pythonista''). 

Vayamos entonces con un ejemplo más complejo. 

Ahora en los siguientes dos pasos vinculamos primero el nombre \verb|a| a una lista con dos números, y luego \verb|b| a otra lista con los mismos dos números.

\jupynotex[1]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-05.pdf}
\end{center}

(El diagrama tiene una simplificación, en pos de la legibilidad: en verdad la lista no tiene a los números ``adentro'', sino que los números son otros objetos en la memoria, y desde cada posición de la lista se los referencia; vamos a ver esto mismo en los próximos diagramas cuando la complejidad lo amerite, pero en este caso solamente para los números no vale la pena.)

Vemos que en memoria tenemos dos objetos lista con el mismo contenido. Podemos adivinar que si le preguntamos a Python si ambos nombres apuntan a objetos iguales, nos dirá que sí, pero si le preguntamos si los dos nombres apuntan \textit{al mismo objeto}, nos dirá que no.

\jupynotex[2-3]{Chapters/intro/code/tipos-pensando.ipynb}

El primer comparador es el de ``igualdad'', mientras que el segundo es de ``identidad''. Vamos a ver más comparadores luego cuando veamos el \mip{if} en \ref{sub:if}.

Modifiquemos ahora una de las listas.

\jupynotex[4-5]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-06.pdf}
\end{center}

Vemos que la lista \verb|a| ahora tiene un elemento más, mientras que la \verb|b| sigue con su estado anterior, como podíamos esperar.

Intentemos algo nuevo, ahora usemos el \verb|=| entre dos nombres. Acá es importante que recordemos que no podemos vincular un nombre a otro nombre (apuntar con la flechita de un nombre a otro nombre), sino que lo que termina sucediendo es que ese nombre nuevo queda vinculado al objeto que apuntaba el otro nombre.

\jupynotex[6-8]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-07.pdf}
\end{center}

Es por eso que si ahora comparamos la igualdad y la identidad entre \verb|c| y \verb|b| Python contestará verdadero en ambos casos, porque ambos nombres apuntan al \textit{mismo} objeto.

Si ahora modificamos la lista \verb|c|, vemos que también se modifica \verb|b|. Habiendo escrito eso, hagamos el ejercicio de entender que esa frase es inexacta, y casi tramposa. Porque \verb|c| o \verb|b| no son listas, son nombres que apuntan a una lista, la misma, entonces tampoco tiene sentido decir que ``también se modifica''. Entonces, escrbiendo esa frase correctamente, podríamos decir que ``podemos modificar la lista y ver ese cambio, usando tanto un nombre como el otro'', que es lo que vemos en el siguiente paso.

\jupynotex[9-10]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-08.pdf}
\end{center}

Arranquemos otro ejemplo. 

Volvemos a tener dos listas con números, y ahora también armamos una tercer lista que incluye las primeras dos. En verdad las dos primeras listas no están ``adentro'' de la primera, sino que son referenciadas en cada posición. Esto es exactamente lo mismo que mencionábamos arriba acerca de que dibujábamos a los números adentro de la lista pero en verdad eran objetos también en la zona de memoria, referenciados desde la lista. 

En este caso en el dibujo seguimos con la simplificación de dibujar a los números adentro de la lista, pero somos más precisos con la tercer lista apuntando a las primeras dos.

\jupynotex[11]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-09.pdf}
\end{center}

Si ahora modificamos la lista que llamamos \verb|a|, obviamente vamos a ver que esa lista está cambiada, pero también vamos a ver reflejado ese cambio si miramos \verb|c|, ya que estamos hablando en definitiva de la misma lista vista directamente o a través de una posición de la otra lista.

\jupynotex[12-13]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-10.pdf}
\end{center}

Por otro lado, si hacemos \mip{b = "foo"} tenemos que entender que no estamos modificando el objeto referenciado por \verb|b| sino que realmente estamos revinculando el nombre \verb|b| a otro objeto, y por lo tanto el objeto anterior (el que dejamos de referenciar cuando apuntamos \verb|b| a otro lado) queda intacto. 

\jupynotex[14-15]{Chapters/intro/code/tipos-pensando.ipynb}

\begin{center}
    \includegraphics[width=200pt,keepaspectratio=true]{Chapters/intro/imgs/penspyth-11.pdf}
\end{center}

A diferencia del ejemplo que teníamos al principio de la subsección, donde el objeto ``viejo'' quedaba sin uso y decíamos que Python eventualmente lo iba a eliminar para liberar memoria, en este caso el objeto que antes era \verb|b| no queda totalmente desreferenciado, sigue siendo apuntado por \verb|c|, con lo cual permanecerá en memoria sin problemas.

E incluso podríamos volver a asignarle otro nombre, y seguir interactuando con el objeto directamente a través del nuevo nombre:

\jupynotex[16-18]{Chapters/intro/code/tipos-pensando.ipynb}

Como nota final, cabe destacar que el comparador de identidad \mip{is}, con la excepción de cuando preguntamos \mip{is None} o \mip{is not None} (que queda bien en inglés), se usa en contadísimas ocasiones, en general necesitamos comparar por igualdad con el \mip{==}.


\subsection{Conjuntos}

Los conjuntos son contenedores de objetos, se delimitan con llaves, y cada objeto (sus elementos internos) se separan con comas.

A diferencia de otros contenedores que vimos previamente, los conjuntos no son secuencias, ya que los elementos dentro del conjunto no tienen un orden en particular. Es hasta inexacto decir que ``están desordenados'', porque directamente este tipo de dato no tiene el concepto de orden.

Las propiedades más interesantes de los conjuntos son las matemáticas: cada elemento puede estar solamente una vez, y además podemos realizar intersecciones, uniones y diferencias entre ellos.

\jupynotex[1-6]{Chapters/intro/code/tipos-sets.ipynb}

El conjunto es el tipo de dato dejado de lado más injustamente de todo el lenguaje, sospechamos que esto es así porque en otros lenguajes no se encuentra, entonces les programadores no se acostumbran a usarlo. Sin embargo, es muy poderoso y una vez que aprendamos a expresar nuestros algoritmos utilizando las capacidades de los conjuntos, evitaremos hacer un montón de bucles y comparaciones innecesarias en nuestros programas.

Sus elementos internos pueden ser solamente objetos inmutables (en verdad, podemos tener objetos que hagamos nosotros que siendo mutables, se les pueda calcular el \mip{hash} en función de propiedades que no cambien, pero por simplicidad pensemos en objetos inmutables). Esto es porque para decidir si un elemento pertenece a un conjunto se usa su hash (de forma similar a los diccionarios que veremos luego). Una implicancia de esta propiedad es que es extremadamente rápido verificar si un elemento pertenece a un determinado conjunto, aunque este sea muy grande (porque se calcula su hash, y listo), en contraposición con lo que sucede con una lista o una tupla (porque en estos casos hay que comparar todos los objetos, algo potencialmente prohibitivo dependiendo del tamaño del contenedor).

\begin{info}
En este contexto, un hash es un número entero calculado a partir de los atributos del objeto. Aquellos objetos iguales tendrán el mismo hash. Los conjuntos y diccionarios usan este hash como referencia en su funcionamiento, de ahí la restricción de que los objetos no cambien (para que sigan teniendo siempre el mismo hash).
\end{info}

Los conjuntos son objetos mutables, y como tales tienen métodos para agregar y eliminar elementos internos. 

En el siguiente ejemplo vemos como podemos agregar objetos de a uno, o muchos simultáneamente (usando un iterable que los contiene). En ambos casos, tenemos que recordar la propiedad de los conjuntos de que no pueden tener objetos repetidos.

\jupynotex[7-11]{Chapters/intro/code/tipos-sets.ipynb}

Tenemos varias formas de remover elementos de los conjuntos, una que saca el elemento indicado pero falla si no está, otra que saca el elemento indicado (sin fallar si no está), y otra que saca un elemento de forma arbitraria (fallando si el conjunto estaba ya vacío):

\jupynotex[12-17]{Chapters/intro/code/tipos-sets.ipynb}

Como con el resto de los tipos, podemos usar el constructor para convertir entre ellos; en este caso el constructor toma cualquier iterable y se queda con los elementos que recibe:

\jupynotex[18-19]{Chapters/intro/code/tipos-sets.ipynb}


\subsection{Diccionarios}

Los diccionarios también se delimitan con llaves, como los conjuntos, pero en este caso lo que se separan por comas son pares de objetos, cada par siendo una clave y un valor (separados entre sí por dos puntos).

Es que los diccionarios, a diferencia de los otros contenedores que vimos hasta ahora (listas, conjuntos, etc) guardan objetos identificados cada uno por una determinada clave. Los valores guardados pueden ser cualquier objeto de Python, mientras que las claves pueden ser objetos que se les puede calcular el hash.

La forma más directa de acceder a los valores guardados es a través de sus respectivas claves, pero también podemos listar todas las claves, todos los valores, e incluso todos los ítems (pares clave/valor).

\jupynotex[1-5]{Chapters/intro/code/tipos-dicts.ipynb}

Cada clave puede estar una sola vez en el diccionario (porque se accede a través del hash de las claves, de forma similar a lo que veíamos con los conjuntos), entonces si asignamos un nuevo valor a una clave ya presente, estaremos pisando el valor anterior. Si la clave no estaba, estaremos creando un nuevo ítem en el diccionario.

\jupynotex[6-8]{Chapters/intro/code/tipos-dicts.ipynb}

Tengamos en cuenta que desde Python 3.6 los diccionarios recuerdan el orden de inserción de sus claves (antes no tenían un orden en particular).

Si accedemos a una clave que no está presente en el diccionario, se genera una excepción de tipo \mip{KeyError}. A veces es útil usar el método \mip{get} que accede al diccionario y devuelve el valor correspondiente a la clave si es que la clave existe, pero en caso de que la clave no exista devolverá un valor que podemos especificar (o \mip{None} si no indicamos nada).

\jupynotex[9-14]{Chapters/intro/code/tipos-dicts.ipynb}

Podemos borrar elementos del diccionario con la declaración \mip{del}, pero también a veces es útil extraer el valor correspondiente a la clave que estamos borrando, y para eso tenemos el método \mip{pop}, al que si le pasamos un valor por default soportará no encontrar a la clave indicada.

\jupynotex[15-20]{Chapters/intro/code/tipos-dicts.ipynb}

Podemos crear diccionarios a partir de otras estructuras, cualquier iterable en verdad, pero tendrán que ser de pares de valores, donde cada par será clave/valor. También podemos crear diccionarios tomando como fuente las claves, usando el método \mip{fromkeys}, pero en este caso las claves tendrán siempre el mismo valor inicial. Y como detalle especial con este tipo de datos podemos usar una forma de pasar parámetros a las funciones que en este caso es particularmente útil (aunque sólo para el caso donde las claves son cadenas).

\jupynotex[21-24]{Chapters/intro/code/tipos-dicts.ipynb}


\subsection{Iteradores}

Antes de irnos de la Sección de Tipos de datos, mencionemos un concepto importante en Python: los iteradores.

A nivel de definición general, un iterador se refiere al objeto que permite al programador recorrer un contenedor. Prestemos atención a la diferencia entre el contenedor en sí (como colección de elementos) del iterador (que nos permite recorrer esos elementos).

Esta característica se expresa en muchos rincones del lenguaje. Tenemos la declaración \mip{for}, que veremos más adelante en la Sección \ref{sub:for}, que nos permite construir un bucle alrededor de iterar un objeto, pero también podemos hacerlo a mano, aunque de esta manera tenemos que pedirle al objeto iterable que nos de un iterador:

\jupynotex[1-6]{Chapters/intro/code/tipos-iters.ipynb}

Esa excepción que vemos ahí es perfectamente normal, es el mecanismo que tienen los iteradores para indicar que no hay más elementos para entregar.

Una forma útil en el intérprete interactivo de iterar un objeto y ver el resultado es a través del constructor \mip{list}. Usémoslo y veamos como en Python muchos tipos integrados en el lenguaje soportan el protocolo de iteración (decimos que son ``iterables''):

\jupynotex[7-11]{Chapters/intro/code/tipos-iters.ipynb}

No todos los tipos soportan este protocolo, claro. Por ejemplo, no se puede iterar un número entero, ya que no es un contenedor, no tiene elementos para entregar.

También tengamos en cuenta que normalmente cada vez que pidamos un iterador vamos a tener uno ``fresco'', que arrancará desde el principio (aunque nosotros podríamos cambiar este comportamiento si hacemos nuestros propios tipos de datos). Pero si trabajamos sobre el iterador puntualmente, podemos pedirle elementos de diversas maneras sin tener que volver a comenzar.

\jupynotex[12-16]{Chapters/intro/code/tipos-iters.ipynb}

Finalmente, prestemos atención cuando estamos iterando un objeto, ya que el mismo puede potencialmente entregar una cantidad muy grande de elementos, lo cual no tiene sentido tener en memoria simultáneamente. Mostremos un ejemplo de esto con la función integrada \mip{range}, que entrega números en un determinado rango, ahí vemos como para un rango chico podemos iterarlo completamente con una lista, pero para uno muy grande, aunque podamos iterarlo a mano, realmente no tiene sentido hacerlo hasta el final.

\jupynotex[17-19]{Chapters/intro/code/tipos-iters.ipynb}

Así y todo \mip{range} en algún momento va a terminar. Pero podemos tener generadores que sean infinitos, ya veremos como construirlos cuando hablemos de Funciones \ref{sub:funciones}.



\section{Controles de flujo}

En esta sección mostraremos las distintas declaraciones de Python que nos permiten controlar el flujo de ejecución de un programa, que hasta ahora veíamos como lineal.

Python tiene pocas estructuras en este sentido (no repitiendo innecesariamente funcionalidad, ``simple es mejor que complejo''), pero las pocas que tiene son poderosas e interesantes.

En esta sección también incluimos \textit{excepciones}, que aunque también se utilizan para manejar errores, en realidad es un concepto más amplio (se utilizan para situaciones excepcionales, no sólo errores), y la naturaleza de las mismas hacen que el flujo del programa se modifique.


\subsection{If, elif, else}\label{sub:if}

Comenzamos con el control de flujo más sencillo, el \mip{if}. La estructura básica es muy simple:

\begin{verbatim}
if <expresión>:
    <bloque de código>
\end{verbatim}

Si la expresión es verdadera, se ejecuta el bloque de código; si no, no.

¿Qué es una ``expresión'' en este contexto? Una expresión es una combinación de valores, variables, operadores y llamadas a funciones. Cuando sea evaluada, para el \mip{if} va a terminar siendo falsa o verdadera, no hay otra. 

Más abajo seguiremos hablando de las expresiones, pero ahora centrémonos en el bloque de código que es lo que se ejecuta si la expresión es verdadera. No es más que una secuencia de líneas de código, que puede ser una o más (no cero, y sin límites prácticos en su cantidad). El comienzo y finalización del bloque está marcado por su sangría (que muchas veces llamamos ``indentación'', término que aunque es usado muchísimo es solamente un anglicismo de \textit{indentation}).

Esa sangría puede ser cualquier cantidad de espacios o tabuladores (¡pero no mezclarlos! y se recomienda usar cuatro espacios), con la condición de que sea consistente. Por ejemplo, si un bloque arranca con la linea cuatro espacios a la derecha, siempre estará sangrado igual durante todo el bloque (a menos que haya bloques anidados, claro) y luego terminará volviendo a la columna original.

Ejemplo:

\begin{py}
if foo == 42:
    print("foo vale 42")  # arranca el bloque con 4 a la derecha
    print("segunda linea")  # segunda linea ok
      print("tercera")  # esta está mal, porque está demasiado a la derecha
    if bar == 33:
        print("bar es 33")  # esta está bien, es un bloque nuevo adentro del otro
    print("muchas líneas")  # ok también: cierra el bloque interior, y vuelve a la columna original
  print("vamos cerrando")  # mal! si cerramos el bloque debemos volver a la columna original de este
print("afuera")  # esta está bien, ya afuera del bloque del if
\end{py}

A la estructura del \mip{if} le podemos agregar una especie de continuación:

\begin{verbatim}
if <expresión 1>:
    <bloque de código 1>
elif <expresión 2>:
    <bloque de código 2>
\end{verbatim}

Si la expresión 1 es verdadera, se ejecutará el bloque de código 1 y se ignorará el resto. Pero si la expresión 1 es falsa, se evalúa la expresión 2: si es verdadera se ejecutará el bloque 2, sino termina.

Y finalmente podemos agregarle una especie de salida final:

\begin{verbatim}
if <expresión 1>:
    <bloque de código 1>
elif <expresión 2>:
    <bloque de código 2>
else:
    <bloque de código 3>
\end{verbatim}

El bloque de código 3 se ejecutará si todas las expresiones de la estructura fueron evaluadas a falso.

El \mip{if} es obviamente obligatorio (arranca la estructura), pero el \mip{elif} es opcional (y se pueden poner cuantos queramos, uno abajo del otro cada uno con su expresión a evaluar), y el \mip{else} es también opcional pero no puede haber más de uno.

Veamos un ejemplo más real:

\jupynotex[1-2]{Chapters/intro/code/flujo-if.ipynb}

Claro que esa estructura se puede extender mucho más. En la actualidad Python no tiene una declaración ``case'' como muchos otros lenguajes. Esto se resuelve con estructuras \mip{if/elif} si son relativamente pocos casos, o guardando funciones en un diccionario si son más.

En 2021, en la versión 3.10, Python ganó la posibilidad de realizar \emph{pattern matching}, una característica bastante útil con muchas vueltas interesantes. Con esta nueva funcionalidad, usándola de forma más bien básica, se podría tener algo similar a la declaración ``case'', pero les recomendamos mirar su PEP \cite{pep-0622} para profundizar sobre este tema.

Volvamos sobre algo que prudentemente esquivamos al principio de la subsección: las expresiones.

Decíamos que una expresión es una combinación de valores, variables, operadores y llamadas a funciones. Esto es bastante genérico, y hay pocas cosas que no pueden ser incluidas en una expresión, como definiciones de funciones o clases, importar módulos, etc. En la práctica podemos hacer casi todo lo que deseamos, y esto nos permite ser bastante expresivos, por ejemplo como veíamos arriba al comparar un valor con el resultado de la función \mip{date} que estamos llamando ahí mismo.

A esto hay que sumarle que todos los tipos de datos integrados en el lenguaje también son evaluables a verdadero o falso, lo cual podemos revisar sencillamente con la función \mip{bool} (como regla general, el objeto evalúa a False si vale cero o está vacío, sino a True).

\jupynotex[3-7]{Chapters/intro/code/flujo-if.ipynb}

Y además tenemos los operadores de comparación:

\begin{itemize}
\item \mip{==} igual a
\item \mip{!=} diferente de
\item \mip{is} es el mismo objeto que (identidad)
\item \mip{<} menor que
\item \mip{<=} menor o igual que
\item \mip{>} mayor que
\item \mip{>=} mayor o igual que
\end{itemize}

Todo esto nos permite ser muy expresivos al armar las estructuras \mip{if}. 


\subsection{While}\label{sub:while}

El \mip{while} es una estructura de control de flujo que nos arma un bucle alrededor de ese bloque de código, repitiendo ese bloque en función de la evaluación de una expresión:

\begin{verbatim}
while <expresión>:
    <bloque de código>
\end{verbatim}

Al arrancar el bucle, Python evalúa la expresión, si es falsa sale y nunca ejecuta el bloque de código. Si es verdadera ejecuta ese bloque de código, y vuelve a evaluar la expresión, si es falsa sale, sino ejecuta el bloque, y así hasta que la expresión de falso o se interrumpa por algo (pero potencialmente durante mucho mucho tiempo, hasta que el Sol se apague, digamos).

Veamos un ejemplo:

\jupynotex[1]{Chapters/intro/code/flujo-while.ipynb}

Ya hablamos al explicar el \mip{if} \ref{sub:if} tanto de la expresión como del bloque de código, no hay mucho para agregar en ese aspecto. Por otro lado, con el \mip{while} vemos que aparecen tres nuevas declaraciones, veámoslas.

El \mip{break} nos permite interrumpir el bucle en la mitad de su ejecución. Si el código toca un \mip{break}, entonces, el bucle se corta y sigue con lo que venía a continuación del mismo, sin terminar el bucle y sin volver a evaluar la expresión.

\jupynotex[2]{Chapters/intro/code/flujo-while.ipynb}

El \mip{continue} nos permite abortar la pasada actual del bucle, volviendo al principio del mismo, lo que incluye volver a evaluar la expresión. Vemos a continuación como el ``3'' no se imprime, porque al tocar el \mip{continue} vuelve a recomenzar el bucle, sin llegar al \mip{print} en ese caso.

\jupynotex[3]{Chapters/intro/code/flujo-while.ipynb}

Si usamos el \mip{else} vamos a poder decidir si el bucle \mip{while} terminó porque su expresión evaluó a falso o fue cortado con un \mip{break}. Lo podemos pensar como en el \mip{if}: si la expresión evalúa a verdadero se ejecuta el bucle, si evalúa a falso se ejecuta el bloque del \mip{else}.

La combinación \mip{while} con el \mip{else} no es muy utilizado, en parte porque no lo vemos en otros lenguajes, pero es muy útil cuando justamente queremos saber si salimos del while en un caso o en el otro (lo que se resuelve en otros lenguajes utilizando otra variable como bandera).

Veamos ambos comportamientos en los siguientes ejemplos:

\jupynotex[4-5]{Chapters/intro/code/flujo-while.ipynb}


\subsection{For}\label{sub:for}

El \mip{for} es una declaración que nos permite recorrer iterables, ejecutando un bloque de código por cada uno de esos iterables (y haciendo referencia al elemento obtenido del iterable en cada momento usando un nombre que nosotros especificamos).

Si entendemos esa definición, la estructura es casi autodescriptiva:

\begin{verbatim}
for <nombre> in <iterable>:
    <bloque de código>
\end{verbatim}

Veamos un ejemplo sencillo:

\jupynotex[1]{Chapters/intro/code/flujo-for.ipynb}

En realidad en lugar del ``nombre'' podemos tener varios nombres, si es que los elementos del iterable que recorremos pueden desempacarse correctamente, y obtendremos el mismo efecto que en la asignación múltiple (más específicamente, tenemos toda la experiencia del desempaquetado de tuplas que explicamos antes \ref{sub:tuplas}):

\jupynotex[2]{Chapters/intro/code/flujo-for.ipynb}

Vale la pena que aclaremos que el \mip{for} es más parecido al ``foreach'' de otros lenguajes, y diferente al ``for'' de C o al ``do'' de Fortran, por ejemplo, que sólo cuentan números entre un principio y final (en general para indizar una estructura y obtener los elementos internos de la misma). En verdad la necesidad de trabajar con rangos de números es real, y para eso Python tiene una función integrada \mip{range}, en el que podemos especificar el final del rango (arrancando por default en cero), o inicio y final, e incluso el paso:

\jupynotex[3-6]{Chapters/intro/code/flujo-for.ipynb}

Prestemos atención que el ``desde'' es inclusivo, mientras que el ``hasta'' es exclusivo; esto aunque quizás sea sorprendente tiene sentido en la foto más grande del funcionamiento general de Python. Por ejemplo, si queremos los índices para una lista de 4 elementos, haremos \mip{range(4)} y eso nos dará el 0, 1, 2 y 3 que son las posiciones de una lista de 4 elementos. También es muy práctica la propiedad de que si hacemos \mip{range(M, N)} la cantidad de números que obtendremos es \mip{N - M}.

Para el ejemplo utilizamos el \mip{list} porque el \mip{range} es un generador de números, entonces tenemos que consumirlo para ver esos números. Por supuesto que lo podemos iterar directamente con el \mip{for}:

\jupynotex[7]{Chapters/intro/code/flujo-for.ipynb}

El \mip{for} es un bucle, y como con el otro bucle de Python (el \mip{while}, de la Sección \ref{sub:while}) podemos afectar el comportamiento utilizando el \mip{break} (para interrumpir el bucle y salir), el \mip{continue} (para abortar la pasada del bucle y volver al principio, obteniendo un nuevo elemento del iterable), e incluso el \mip{else} (para discernir si el \mip{for} terminó porque se nos acabó el iterable o porque cortamos con un \mip{break}.

Veamos algunos ejemplos usando estas funcionalidades. Arrancamos con el \mip{break} y el \mip{continue}, viendo como corta en un caso y como vuelve al principio en el otro esquivando el resto del bucle:

\jupynotex[8-9]{Chapters/intro/code/flujo-for.ipynb}

Y veamos el \mip{else}, para el caso en que terminamos el \mip{for} por consumir totalmente el iterable o porque encontramos un \mip{break}:

\jupynotex[10-11]{Chapters/intro/code/flujo-for.ipynb}

Hay un caso de uso típico en los \mip{for} que es arrancar con una lista, realizarle una operación, y terminar con otra lista con los resultados de esa operación. Por ejemplo, podemos tener una lista de números y queremos calcular sus cuadrados:

\jupynotex[12]{Chapters/intro/code/flujo-for.ipynb}

Esta construcción es tan usual que Python tiene una sintaxis especial que nos permite escribir lo mismo pero de forma más reducida, con la ventaja que hasta queda más legible; se denomina \textit{comprensión de listas} (en inglés \textit{list comprehension}), y se define usando corchetes para delimitar la estructura, con los elementos sintácticos del \mip{for} adentro:

\jupynotex[13]{Chapters/intro/code/flujo-for.ipynb}

Podemos leer la segunda linea como ``armamos una lista con ene al cuadrado para cada ene en números'', y hace exactamente eso. Es mucho más fácil de entender que el \mip{for} del ejemplo anterior que hace lo mismo pero a lo largo de varias líneas (entonces lo tenemos que seguir, ir y volver con la vista, entender qué hace con la lista que definimos al principio, etc.); en el caso de la \textit{comprensión de listas} al primer vistazo (cuando reconocemos la estructura) ya sabemos que generamos una nueva lista realizando una operación con los elementos de un iterable, y nada más.

En realidad podemos complejizar apenas esa estructura, para el caso en que queramos filtrar algunos elementos del iterable fuente. Veamos los mismos ejemplos que recién pero calculando logaritmos solamente para los valores mayores a cero.

\jupynotex[14-15]{Chapters/intro/code/flujo-for.ipynb}

Una generalización de esta estructura nos permite armar una \textit{comprensión de conjuntos} (al delimitar la estructura con llaves) e incluso una \textit{comprensión de diccionarios} (al delimitar la estructura con llaves y tener clave y valor separados por dos puntos:

\jupynotex[16-18]{Chapters/intro/code/flujo-for.ipynb}


\subsection{Excepciones}\label{sub:excepciones}

El sistema de manejo de errores de Python es a través de excepciones. 

\subsubsection{¿Qué son las excepciones?}

Una excepción es un evento que ocurre durante la ejecución normal del programa e interrumpe el flujo normal del programa. En general, cuando un programa en Python encuentra una situación que no puede manejar, levanta una excepción.

Entonces, a diferencia de otros lenguajes que luego de llamar a una función (por ejemplo) tenemos que revisar el resultado para ver si indica que hubo un problema, en Python el resultado será lo que tenga que devolver la función normalmente, si es que la función terminó sin inconvenientes. Pero si hubo un problema, obtendremos una excepción, que podemos manejar o dejar continuar.

Hagamos un pequeño programa para ver eso:

\pyfile{Chapters/intro/code/excep.py}

Al ejecutar ese código, obtendremos:

\begin{verbatim}
$ python3 excep.py 
antes
Traceback (most recent call last):
  File "x.py", line 2, in <module>
    1 / 0
ZeroDivisionError: division by zero
\end{verbatim}

Vemos que se imprime el ``antes'', pero luego la ejecución se interrumpió al encontrar un error (al intentar dividir por cero). En ese punto, se levantó una excepción, y como no se capturó la terminó agarrando el intérprete de Python, el que interrumpió al programa y mostró un \textit{traceback} por pantalla. Un traceback (término que usamos en inglés, ya que nunca se popularizó decirles ``trazas de rastreo'') es información que nos da el intérprete para entender de dónde viene el problema.

Tiene tres partes, un título que nos indica el comienzo del traceback (linea 3), un contenido cuyo largo dependerá de cuan profundo en la pila de llamadas a funciones haya sucedido el problema (líneas 4 y 5), y una última linea (la 6) mostrando el tipo de excepción y un mensaje (en nuestro caso \mip{ZeroDivisionError}, y el mensaje indicando eso).

Para entender mejor la parte del medio veamos un ejemplo apenas más complejo (usando funciones, aunque nos adelantemos un poco a cuando las expliquemos formalmente en la Sección \ref{sub:funciones}).

Veamos primero que pasaría si todo sale bien y no nos encontramos con ningún problema:

\pyfile{Chapters/intro/code/excep-stacks-ok.py}

Al ejecutar ese código, obtendremos:

\begin{verbatim}
1. inicio
2. antes en el módulo
3. antes en f
4. en g
5. después en f
6. después en el módulo
7. fin
\end{verbatim}  

Los números se corresponden al siguiente diagrama donde vemos la secuencia de ejecución de las distintas funciones:

\begin{center}
    \includegraphics[width=300pt,keepaspectratio=true]{Chapters/intro/imgs/excep-stack-1.pdf}
\end{center}

Ahora veamos qué pasaría si en la función ``g'' nos encontramos con un problema. Modifiquemos esa función:

\pyfile{Chapters/intro/code/excep-stacks-pumba.py}

Vemos que tenemos los resultados de los primeros prints y luego un traceback, pero no lo que veíamos antes:

\begin{verbatim}
1. inicio
2. antes en el módulo
3. antes en f
4a. antes en g
Traceback (most recent call last):
  File "x.py", line 14, in <module>
    f()
  File "x.py", line 10, in f
    g()
  File "x.py", line 5, in g
    print("¿uno sobre cero?", 1 / 0)
ZeroDivisionError: division by zero
\end{verbatim}  

Podemos ver mejor el flujo de ejecución en este otro diagrama que representa lo que acabamos de experimentar:

\begin{center}
    \includegraphics[width=300pt,keepaspectratio=true]{Chapters/intro/imgs/excep-stack-2.pdf}
\end{center}

Allí vemos que el flujo de ejecución se modifica. Cuando llegamos al punto del problema, el resto de la función ``g'' no se ejecuta, sino que se genera una excepción que vuela hasta el punto donde la función fue llamada (linea roja que llega a ``f''). El resto de esta función tampoco se ejecuta, como la excepción no fue capturada seguirá subiendo por las funciones hasta llegar a nivel de módulo, donde Python interrumpe el proceso mostrando el traceback.

La mejor forma que tenemos para entender lo que está pasando cuando hay un error es leer cuidadosamente el traceback. Recomendamos hacerlo de abajo para arriba. 

Para el ejemplo anterior, vemos que tuvimos una excepción por división por cero en la linea 5 en la función ``g'' (donde hicimos \mip{1 / 0}), lo cual viene de la linea 10 en la función ``f'' (donde hicimos \mip{g()}), que a su vez viene de la linea 14 a nivel del módulo (donde hicimos \mip{f()}).

Como tenemos un stack de largo tres (el cuerpo principal del programa más las dos funciones) tenemos tres pares de líneas en el centro del traceback. 

Entonces, cada par de líneas de ``la parte central'' del traceback corresponde a un nivel del stack, y en cada caso nos muestra dónde se sucedió el problema para ese nivel del stack (en qué archivo, en qué linea y el contexto), y luego la linea en cuestión (que podríamos ver en el archivo/posición indicado, pero así es más cómodo).

\subsubsection{Capturando y levantando excepciones} 

Podemos capturar las excepciones que se sucedan con un bloque \mip{try}. La construcción típica es usarlo en conjunto al \mip{except}:

\begin{verbatim}
try:
    <bloque de código>
except:
    <bloque de código>
\end{verbatim}

El primer bloque de código, correspondiente al \mip{try} es el supervisado, si se sucede alguna excepción en ese bloque, el \mip{except} entra en juego y se ejecutará el segundo bloque de código; si ninguna excepción se levanta en el bloque supervisado, el \mip{except} será ignorado completamente.

Veamos ambas situaciones en un ejemplo mínimo:

\jupynotex[1-2]{Chapters/intro/code/flujo-excep.ipynb}

Hay dos reglas de oro para seguir cuando escribimos estas estructuras. La primera es que debemos supervisar el mínimo de código posible (minimizar la cantidad de código dentro del bloque del \mip{try}), la segunda es que debemos capturar solamente las excepciones que estamos esperando que puedan suceder (especificar el \mip{except} lo más posible, no como hasta ahora que está capturando todo).

La primer regla es fácil de entender, pero veamos un ejemplo de cómo es útil especificar el \mip{except} lo más posible. Supongamos el siguiente código, donde obtenemos un valor (supongamos de una medición) y calculamos uno sobre eso; excepcionalmente podemos tener un cero como valor, pero eso sería que el instrumento está descalibrado, entonces lo informamos y listo:

\jupynotex[3-4]{Chapters/intro/code/flujo-excep.ipynb}

Sin embargo, supongamos que tenemos un problema más serio, y por un error en nuestro programa terminamos teniendo otra cosa como valor, una cadena:

\jupynotex[5]{Chapters/intro/code/flujo-excep.ipynb}

El mensaje que estamos dando es totalmente equivocado. Tengamos en cuenta que mucha veces también en el bloque del \mip{except} se toman acciones para corregir o paliar el problema, y si tomamos las acciones equivocadas podemos estar complicando aún más la situación.

Entonces, tenemos que ser lo más específicos posibles al capturar la excepción. Para el ejemplo que estamos viendo, nosotros sabemos que podemos llegar a tener una \mip{ZeroDivisionError}, ¡entonces capturemos sólo eso! Si le especificamos un tipo de excepción al \mip{except} (o más de uno, entre paréntesis), capturará la excepción y ejecutará el bloque de código sólo si la excepción es de ese tipo (o de algunos de los varios tipos que pusimos entre paréntesis):

\jupynotex[6-7]{Chapters/intro/code/flujo-excep.ipynb}

Entonces, en el primer caso tenemos el mensaje que esperábamos, mientras que en el segundo caso la excepción no es capturada, la termina agarrando Python y nos genera el traceback correspondiente, lo cual está perfectamente bien, porque es información útil para encontrar el error en nuestro programa.

Hay situaciones, sin embargo, en que igualmente queremos capturar todo lo que pueda llegar a suceder, lo cual se justifica en procesos que son muy largos y que no queremos que se interrumpan nunca, o siempre tienen que estar levantados, y necesitamos capturar todas las excepciones para poder informarlas y seguir trabajando. 

Pero incluso en estas situaciones no es recomendable poner el \mip{except} ``pelado'', ya que hay excepciones que son internas al funcionamiento de Python y no debemos capturarlas. En estos casos es muy útil que las excepciones en Python estén dispuestas en forma de árbol, y que especificando un tipo de excepción realmente estamos capturando las excepciones de ese tipo y todas las de su rama (este árbol lo podemos ver en la documentación \cite{stdlib_exceptree}. 

Entonces, podemos capturar \mip{Exception} (que como vemos en el árbol de excepciones incluye a casi todas menos tres muy específicas), y obtendremos el efecto deseado. Es más, al especificar el tipo de excepción, podemos incluso ponerle un nombre a la excepción que capturamos y manejarla en el bloque de código. 

Veamos todo esto en el ejemplo que traíamos, aprovechando la flexibilidad del \mip{except} que nos permite especificar varios luego de un \mip{try} (el comportamiento en estos casos es parecido a la cadena/secuencia que teníamos con los \mip{if}/\mip{elif}: se va verificando la excepción en orden en todos los \mip{except}, si la excepción es capturada por uno de ellos se ejecuta su bloque de código y deja de verificarse en el resto.

\jupynotex[8-9]{Chapters/intro/code/flujo-excep.ipynb}

En verdad, son más las herramientas que podemos usar con el \mip{try}, no sólo tenemos el \mip{except}, sino también el \mip{else} y el \mip{finally}, los cuales se pueden usar en cualquier combinación. La estructura completa sería:

\begin{verbatim}
try:
    <bloque de código>
except:
    <bloque de código>
else:
    <bloque de código>
finally:
    <bloque de código>
\end{verbatim}

Veamos un resumen mostrando las características de cada una de esas partes:

\begin{itemize}
 \item \mip{try}: da comienzo al manejo de posibles excepciones, supervisando un bloque de código; es obligatorio incluirlo (da comienzo a la estructura) y puede estar una sola vez.
 \item \mip{except}: ejecuta un bloque de código si en el código supervisado se levantó una excepción, y esa excepción es del tipo definido en el \mip{except} (o incluida en su rama del árbol, como veíamos arriba); puede haber muchos o ninguno, si hay varios la comprobación de la excepción se hace en orden y se ejecuta el bloque de código solamente de aquel que captura la excepción.
 \item \mip{else}: ejecuta su bloque de código solamente si en el código supervisado \textit{no} se levantó una excepción; es opcional y puede haber a lo sumo uno.
 \item \mip{finally}: ejecuta su bloque de código \textit{siempre}, no importa qué haya pasado en el código supervisado; es opcional y puede haber a lo sumo uno.
\end{itemize}

Además de todo el manejo que podemos hacer sobre excepciones que son levantadas en alguna parte del código o por alguna situación, tenemos la opción de levantar nosotres mismos las excepciones integradas de Python, o incluso crear nuevas excepciones para nuestros programas.

Para levantar una excepción sólo tenemos que usar la declaración \mip{raise} y la excepción y el mensaje que queremos levantar:

\jupynotex[10]{Chapters/intro/code/flujo-excep.ipynb}

Vemos en el ejemplo como el tipo de excepción y el mensaje usados son los mostrados en el traceback.

También podemos usar el \mip{raise} sin especificar una excepción, pero solamente en el contexto de manejar alguna excepción que hayamos capturado: en este caso el \mip{raise} lo que hará es ``re-levantar'' la misma excepción. 

Es muy útil para los casos donde capturamos una excepción pero solamente para manejar algunos casos y otros no. Por ejemplo, en las siguientes líneas capturamos un posible error que ignoramos en un caso y en otros no:

\jupynotex[11-12]{Chapters/intro/code/flujo-excep.ipynb}

Definir nuestros propios tipos de excepciones es muy simple, aunque para ello necesitamos la sintaxis de clases (que veremos más adelante \ref{sub:clases}). El único requisito es que tenemos que ``heredar'' una excepción integrada de Python; de nuevo, el concepto de ``herencia'' todavía no lo vimos, pero para nuestro propósito es lo que ponemos entre paréntesis en la definición, veamos un ejemplo simple:

\jupynotex[13]{Chapters/intro/code/flujo-excep.ipynb}

Es importante elegir de qué excepción heredamos porque eso es lo que termina armando ``el árbol de excepciones'' que mencionábamos arriba cuando decíamos que \mip{except} captura el tipo de excepción indicado y a toda su rama.

En el caso del ejemplo estamos heredando \mip{Exception}, pero podríamos heredar alguna otra excepción cuya semántica esté más cerca de la excepción que estamos definiendo (para ello es interesante empaparse de los tipos de excepciones que trae Python \cite{stdlib_exceptypes}. Por ejemplo, en nuestro caso probablemente estaríamos mejor heredar de \mip{ValueError}, ya que está relacionada con un valor obtenido.

Una vez definida, la usamos como cualquier otra excepción:

\jupynotex[14]{Chapters/intro/code/flujo-excep.ipynb}


\section{Encapsulando código}

Encapsular código es el acto que nos permite acomodar determinadas líneas de código en alguna estructura para poder reutilizarlas a conveniencia.

La forma más sencilla en Python de lograr esto son las funciones, que es lo primero que estudiaremos en esta sección. Luego mostraremos las clases, que nos permiten encapsular no sólo el código sino también los objetos sobre los cuales trabaja ese código (abriéndonos las puertas a la Programación Orientada a Objetos), y finalmente hablaremos de módulos y paquetes, que son capas superiores que nos permiten encapsular funciones y clases para usarlas de distintos programas.


\subsection{Funciones}\label{sub:funciones}

Como mencionábamos al principio de la sección, la función es la estructura más sencilla para encapsular código. 

Nos permite escribir un bloque de código (con sus estructuras de control de flujo, con sus propios bloques de código, etc) de forma que después podremos ejecutar ese bloque de código ``llamando'' a la función desde cualquier lado.

La forma más sencilla de la estructura de una función es:

\begin{verbatim}
def <nombre>():
    <bloque de código>
\end{verbatim}

Esa estructura, aunque funcional, no nos permite pasarle datos ni obtener un resultado. Pero nos sirve para empezar a familiarizarnos con las funciones. Tenemos entonces un ``nombre'' que es el que usaremos para identificar a la función, y un bloque de código (indentado, como corresponde).

Es importante entender la diferencia entre ``definir'' una función y ``llamar a'' (o ``ejecutar'') una función. En el primer caso solamente hacemos que Python compile la estructura y la tenga en memoria lista para usar, mientras que en el segundo caso es realmente cuando el bloque de código de la función se termina ejecutando.

En el siguiente ejemplo podemos ver primero la definición en sí de la función, y cómo podemos referenciarla con su nombre (en el \mip{print}, o directamente en el intérprete interactivo, y la diferencia fundamental con ejecutar esa función, al final del ejemplo, cuando escribimos el nombre de la función seguida de paréntesis (sin nada entre ellos, en este caso, porque la función no recibe parámetros).

\jupynotex[1-4]{Chapters/intro/code/encap-funcs.ipynb}

\begin{info}
En Python cada objeto puede especificar la mejor forma de representarse cuando se llama \mip{str()} o \mip{repr()} al mismo; por default Python mostrará el tipo de objeto y la posición en su memoria interna de objetos.
\end{info}

Tener una función como esa es válido en algunos casos, pero en realidad la mayoría de las veces estaremos pasándole valores a la función y/o recibiendo resultados de la misma.

Para recibir valores, los tenemos que especificar en la definición de la función. Esto se logra de distintas maneras, y es bastante flexible (lo veremos más abajo), pero por ahora, simplificando, digamos que escribimos los nombres con los que haremos referencia a esos valores, y los podremos acceder desde el bloque de código de la función.

En el siguiente ejemplo definimos una función que recibe dos valores (sería un error pasarle uno o tres):

\jupynotex[5-7]{Chapters/intro/code/encap-funcs.ipynb}

Hasta ahora la función ejecuta su bloque de código y termina. Por default, la función siempre devuelve \mip{None} al terminar, pero tenemos control sobre eso mediante la declaración \mip{return}.

Podemos poner cualquier cantidad de \mip{return}s en una función. Si el flujo del código pasa por una linea con \mip{return}, la función termina y devuelve lo que allí se indica (no importa si hay otros \mip{return}s en otros lados de la función).

\jupynotex[8-9]{Chapters/intro/code/encap-funcs.ipynb}

Prestemos atención al detalle de haber llamado a la función y realizar una asignación con el resultado de esa función, para poder trabajar luego con el mismo.

Tengamos en cuenta que podemos obtener más de un resultado cuando termina una función, para lo cual el \mip{return} soporta que escribamos diferentes valores separados por coma y podemos acceder a esos valores con una asignación múltiple.

\begin{info}
En realidad, a bajo nivel, lo que sucede es que el \mip{return} está devolviendo una tupla con esos valores, y luego en la asignación del resultado entra en juego lo que llamamos ``tuple unpacking'' \ref{sub:tuplas}.
\end{info}

Ya con un ejemplo más complejo, armemos una función que recibe dos valores y devuelve la multiplicación y la división de ambos números (¡si es posible! si el segundo número es cero devuelve None allí):

\jupynotex[10-16]{Chapters/intro/code/encap-funcs.ipynb}

No hay más para explorar por el lado de devolver valores, así que volvamos sobre el otro lado de usar funciones: pasarle parámetros.

Vayamos mostrando las distintas alternativas. El modo más básico es lo que veníamos haciendo, definir algunos parámetros y pasar valores para los mismos. Veamos cuando esto funciona bien, y también los errores que tenemos al no respetar ese ``acuerdo básico'':

\jupynotex[17-20]{Chapters/intro/code/encap-funcs.ipynb}

Un detalle básico pero interesante es que hay una correspondencia ordinal entre los parámetros especificados en la definición de la función y los valores que pasamos al llamarla: el \verb|5| va a la \verb|a| y el \verb|6| va a la \verb|b|; es por esto que llamamos ``posicionales'' a estos argumentos (lo vemos también en el mensaje de error en el ejemplo).

Cuando definimos la función podemos especificar que algunos de esos parámetros tengan un valor por default, entonces no va a ser necesario pasarlos cuando llamemos a la función:

\jupynotex[21-24]{Chapters/intro/code/encap-funcs.ipynb}

En el ejemplo vemos que si pasamos sólo el valor para \verb|a|, \verb|c| y \verb|b| tienen sus valores por default. En la segunda llamada pasamos valor para \verb|a| y para \verb|b| (de nuevo, porque son posicionales, el primer valor al primer parámetro, etc.), pero no para \verb|c|. Y finalmente, vemos que si les pasamos valores para los tres, no se consideran sus valores por default.

¿Pero cómo haríamos en el ejemplo anterior para pasar un valor a \verb|a| y a \verb|c|, pero no a \verb|b| (y que tome su valor por default)? Para ello nos tendríamos que salir del esquema de parámetros posicionales y empezar a nombrarlos, lo cual es tan sencillo como especificar para qué parámetro queremos que vaya cada valor:

\jupynotex[21,25]{Chapters/intro/code/encap-funcs.ipynb}

En este caso vemos que pasamos un \verb|9| que va a \verb|a| (¡posicional!) pero luego especificamos que el \verb|7| va para \verb|c|; a \verb|b| no le terminamos pasando un valor, así que toma su default.

En realidad una vez que nombramos los parámetros, podemos escaparnos totalmente al orden de sus posiciones, más allá que en la definición tengan valores por default o no:

\jupynotex[21,26-27]{Chapters/intro/code/encap-funcs.ipynb}

Hasta ahora estamos manejando cantidad de fija de parámetros. Python soporta que en la definición usemos el \mip{*} que consumirá todos aquellos valores que pasemos por posición que no hayan sido tomados todavía:

\jupynotex[28-30]{Chapters/intro/code/encap-funcs.ipynb}

En el ejemplo vemos como en la primer llamada los dos valores que pasamos van a los primeros dos parámetros definidos, pero no quedó nada para \verb|c| (entonces es una tupla vacía), mientras que en el segundo caso ``sobraron'' dos valores, entonces \verb|c| si tiene contenido.

También Python nos ofrece el \mip{**}, que de manera similar consumirá todos los nombrados que no hayan encontrado otro lugar:

\jupynotex[31-33]{Chapters/intro/code/encap-funcs.ipynb}

Para el caso de \mip{*} la estructura donde Python guarda los argumentos posicionales sobrantes es una tupla, ya que sólo es importante el orden, mientras que para el \mip{**} como tenemos valores y nombres, la estructura útil para guardar eso es el diccionario.

Obviamente se pueden combinar todos los casos que estuvimos viendo hasta recién .

\jupynotex[34-36]{Chapters/intro/code/encap-funcs.ipynb}

Todo esto funciona mientras no haya ambigüedades en la definición o en el llamado a la función; en esos casos Python mostrará un mensaje de error indicando el problema.

\jupynotex[37-38]{Chapters/intro/code/encap-funcs.ipynb}

Así como podemos usar en la definición el \mip{*} para guardar excedentes posicionales en una tupla y \mip{**} para los excedentes nombrados en un diccionario, podemos usarlos en las llamadas a las funciones para ``desarmar'' una tupla con los valores o un diccionario con los nombres/valores:

\jupynotex[39-41]{Chapters/intro/code/encap-funcs.ipynb}

Cabe acotar que no estamos mencionando todos los casos posibles, y que hay más reglas y operadores (como forzar a que los parámetros sean nombrados o posicionales), y algunos detalles más, explicados en profundidad en la referencia del lenguaje \ref{referencia_funciones}.


\subsubsection{Espacios de nombres}

Cuando explicamos cómo funcionaba Python con sus objetos y nombres (en lugar de variables con valores, ver Sección \ref{sub:pensando-pythonista}), usamos unos diagramas donde a la derecha teníamos los objetos en memoria, y a la izquierda otra zona donde poníamos los nombres. Este espacio reservado para los nombres se llama justamente ``espacio de nombres'' (en inglés ``namespace''), y es una zona de memoria donde justamente se guardan los nombres que referencian a los otros objetos.

Traemos esto a colación en esta sección porque en Python no tenemos solamente un espacio de nombres, sino que pueden haber muchos, y las funciones tienen mucho que ver en eso.

Cuando arranca Python tenemos un espacio de nombre que se conserva hasta que el proceso termina y es accesible desde todos lados: el espacio de nombre ``global''. Por otro lado, cada vez que ejecutamos una función, se crea otro espacio de nombres, ``local'' a la función, que permanecerá activo mientras las función se está ejecutando y desaparecerá cuando la misma termine.

Tenemos que tener en cuenta que lo que se destruye al terminar la función es el espacio de nombre, no los objetos referenciados por los mismos. Claro, algunos objetos quedarán sin referencia luego de que el espacio de nombre desaparezca (y de esos se encarga la administración automática de memoria de Python), pero puede ser que otros objetos estén referenciados de otros lados, y sigan vivos.

Veamos un ejemplo sencillo:

\jupynotex[42-44]{Chapters/intro/code/encap-funcs.ipynb}

Analicémoslo en detalle, por partes. Lo primero que tenemos es una definición de una función (que todavía no ejecutamos, claro). Luego le ponemos nombre a dos enteros (\verb|x| e \verb|y|), que usamos para llamar a la función. En \textit{ese} momento se ejecuta la función, que nos devuelve 15.

Si vamos a la ejecución de la función, vemos que esos dos enteros los recibe en dos parámetros que llama \verb|a| y \verb|b|, realiza un cálculo y devuelve ese valor. Como parte del procesamiento, la función también define un nombre \verb|x|, pero este se define en el espacio de nombres \textit{local} de la función (igual que \verb|a| y \verb|b|, para el caso).

La \verb|x| definida en el espacio de nombres local apunta al entero 15, y luego de ejecutar la función vemos que, afuera, \verb|x| sigue apuntando al 3 original. Esto es porque afuera estamos usando el espacio de nombres global, no se nos mezcla con el espacio de nombres local de la función.

Es importante entender la diferencia entre ``definir'' un nombre en un espacio de nombres, y tener ``acceso'' a ese nombre (también decimos ``ver'' ese nombre, en inglés se usa ``scope''). Veamos el siguiente ejemplo para resaltar esta diferencia:

\jupynotex[45-49]{Chapters/intro/code/encap-funcs.ipynb}

Arrancamos definiendo una función (que veremos en detalle a continuación, cuando la ejecutemos), y luego se definen en el espacio de nombres global una \verb|x| apuntando a un 8 y una \verb|y| apuntando a un 9.

Cuando ejecutamos la función, esta primero define una \verb|y| apuntando a un 2 y una \verb|z| apuntando a un 3 (en ambos casos, en el espacio de nombres local de la función), y luego hace un print de tres nombres: para \verb|x| e \verb|y| es simple, porque está mostrando lo que encuentra en el espacio de nombres local, pero \verb|z| nos puede sorprender. 

Es aquí donde tenemos que entender que a nivel de visibilidad, desde adentro de la función Python intenta resolver el nombre primero buscando en el espacio de nombres local, y luego si no la encuentra allí busca en el espacio de nombres global. Esta secuencia es importante, porque eso determina que el \verb|y| que encuentra es el que apunta al 2 (¡no al 9!), y para \verb|z| que no está local pero si global, igual la encuentra.

Por otro lado, desde afuera de la función no tenemos visibilidad a su espacio de nombres, por eso cuando al final queremos ver el valor de \verb|z| nos da error de nombre, porque \verb|z| no está definida en el espacio de nombres global (y es en el único en que busca).

Un detalle importante es que como desde adentro de la función tenemos visibilidad sobre los objetos del espacio de nombres global, si los objetos son mutables podremos modificarlos:

\jupynotex[50-53]{Chapters/intro/code/encap-funcs.ipynb}

Aunque podría considerarse una mala práctica de programación (porque la función nos está cambiando objetos que viven fuera de ella), en algunos casos es útil y muy ventajoso poder hacer eso. ¡Usar con precaución!


\subsubsection{Generadores}

Los generadores son un tipo particular de objeto que cuando los iteramos nos dan elementos, pero no los tenían de antes. Los van generando en el momento. Un ejemplo integrado en Python es el \mip{range}. Si hacemos \mip{range(10 ** 100)} obtenemos un objeto que si le pedimos, nos dará enteros entre 0 y 10\textsuperscript{100} - 1, pero obviamente no preparó todos esos números en el momento. Los irá \textit{generando}.

Se usan mucho en Python porque optimizan el uso de memoria y mejoran el rendimiento general. Veamos el siguiente ejemplo que aunque muy simple, muestra una optimización clara que repetida por varios rincones del lenguaje hacen una diferencia importante:

\jupynotex[54]{Chapters/intro/code/encap-funcs.ipynb}

El ejemplo suma los números del 0 al 9, generados por el \mip{range}. Si \mip{range} (en vez de funcionar como generador) armara una lista con los números del 0 al 9, el efecto sería exactamente el mismo, con el detalle que como parte del proceso, se construyó una lista con todos los números en memoria simultáneamente, que luego fue consumida por el \mip{sum}. Esa lista no sirvió para nada, en realidad, sólo ocupó memoria y tiempo para su creación/administración.

Hay distintas formas de construir generadores en Python, pero una de las más simples es armar una ``función generadora''. Parece una función normal con la excepción que dentro de su bloque de código usa la declaración \mip{yield}, que justamente le cambia el comportamiento.

¿Recuerdan que dijimos que las funciones cuando las llamamos se ejecutan hasta que terminan, destruyendo su espacio de nombres local, y que cuando las volvemos a llamar vuelven a ejecutarse desde el principio? Bueno, justamente las funciones generadoras cambian ese comportamiento. Cuando llamamos a la función nos devuelve un generador. Cuando le vamos pidiendo elementos a ese generador lo que va a hacer es ejecutar esa función hasta que llega a un \mip{yield}, devolviéndonos lo que allí se indica, ``pausando'' la ejecución de ese código. Y cuando le pidamos el próximo elemento al generador, ese código ``se despertará'' en el punto en que estaba y continuará su ejecución hasta que termine o encuentre otro \mip{yield}.

Para ver esto en un ejemplo, primero hagamos una versión casera y recortada del \mip{range} con una función clásica, para poder comparar ambos códigos.

\jupynotex[55-57]{Chapters/intro/code/encap-funcs.ipynb}

En esta función vemos lo que mencionábamos arriba. La función genera una lista con los números, luego el \mip{sum} la consume sumando esos números y produce el 45 como resultado. No sólo la lista es innecesaria, también mantener todos los números al mismo tiempo en memoria sólo para sumarlos es un desperdicio de recursos. Esto es obviamente un factor si tenemos una lista muy grande, pero tampoco hay que desestimar la situación con estructuras pequeñas, porque cualquier necesidad de memoria puede disparar que el proceso que estamos ejecutando tenga que salir a pedirle memoria al sistema operativo, y eso siempre es caro.

Convirtamos la función de arriba en generadora.

\jupynotex[58-62]{Chapters/intro/code/encap-funcs.ipynb}

La estructura definida es muy similar, pero notemos que no tenemos la estructura interna ``nros'' (porque no estamos creando esa lista), y que aparece el famoso \mip{yield}.

Cuando ejecutamos esta función generadora, realmente no se empieza a ejecutar el bloque de código, sino que obtenemos el objeto generador en sí, como mostramos en el ejemplo. Al hacer el primer \mip{next} se empieza a ejecutar el código, hasta que llega al \mip{yield}, allí devuelve el valor que teníamos en \verb|n| (el \verb|0|) y la ejecución del código queda suspendida (ya que el control lo tenemos nosotros en el intérprete interactivo). Cuando hacemos el segundo \mip{next}, la ejecución no arranca desde el principio, sino que continua desde donde estaba, sumándole \verb|1| a \verb|n|, luego vuelve a evaluar la expresión del \mip{while} y llega nuevamente al \mip{yield}, devolviéndonos ahora el \verb|1|. 

Si siguiéramos pidiéndole números con el \mip{next}, los seguiríamos obteniendo hasta que la expresión del \mip{while} de falso, y en ese caso vemos que se termina la función. Como es una función generadora, cuando sale de la función en realidad se genera la excepción \mip{StopIteration} que es la que usa Python para indicar que no hay más ítems para iterar. Esto nos permite integrar a estos generadores en todas las estructuras normales de Python.

Finalmente entonces, usamos en el \mip{sum} la función generadora que armamos, que vemos que nos devuelve el mismo resultado que con la estructura clásica, pero sin construir la lista intermedia.

También podemos aplicar este concepto de ``generador'' a las comprensiones de listas \ref{sub:for}, armando directamente ``comprensiones generadoras'', usando paréntesis en lugar de corchetes

\jupynotex[63]{Chapters/intro/code/encap-funcs.ipynb}

Incluso podemos obviar esos paréntesis cuando tenemos a la expresión generadora dentro de una llamada a función (porque los dobles paréntesis son superfluos en Python).

Veamos un simple ejemplo donde sumamos los cuadrados del 0 al 9 de dos formas distintas. 

\jupynotex[64-65]{Chapters/intro/code/encap-funcs.ipynb}

En ambos casos arrancamos con \mip{range} (que es generadora), pero en el primero armamos una lista intermedia con los cuadrados (notemos los corchetes que arman la compresión de listas), mientras que en el segundo tenemos una comprensión generadora (no hace falta poner los paréntesis, ya que aprovechamos los de alrededor.

Para el \mip{sum} es exactamente lo mismo, y tenemos el mismo resultado, pero el segundo caso es más rápido y hasta más legible y conciso.


\subsection{Clases}\label{sub:clases}

Las \textit{clases} son una forma de encapsular código junto a los objetos que son manejados por ese código.

Aunque suena simple, realmente esto nos permite separar en distintas estructuras los distintos objetos que necesitamos manejar con el código para procesarlos, lo cual nos permite modelar eficientemente la realidad que estamos tratando de representar, abriéndonos las puertas de la Programación Orientada a Objetos (en adelante ``POO'').

En este libro mostraremos el funcionamiento básico de las clases, la definición de su estructura, qué implica instanciarlas y las bases del funcionamiento de los objetos que obtenemos, pero no pretendemos enseñar POO en un capítulo, ya que es un tema para todo un libro (¡o más de uno!).

Entonces la idea es que podamos leer y entender código que usa clases, e incluso construir algunas sencillas, sin pretender desbloquear todo su potencial.

La estructura básica de una clase es extremadamente simple:

\begin{verbatim}
class <nombre>:
    <bloque de código>
\end{verbatim}

Con eso ya armamos una clase con el nombre que queramos, y tenemos un bloque de código para continuar. Como con las funciones, las clases nos crean un espacio de nombres diferente, y allí es que empezaremos a agregar código que luego utilizaremos más adelante.

Armemos un ejemplo con más elementos, para empezar a explicarlos:

\jupynotex[1-4]{Chapters/intro/code/encap-clases.ipynb}

En el bloque de código definimos una variable y una función, y luego las usamos. Veamos que hicimos \mip{Foo.a} y \mip{Foo.f()}, porque tanto ``a'' como ``f'' no están en el espacio de nombres global, sino en el de la clase (y como con los módulos, cuando hacíamos \mip{math.sqrt(2)} \ref{sub:intromods}, usamos el punto para indicar que estamos usando un nombre de ``adentro'' de otro objeto). Entonces, es claro que tanto ``a'' como ``f'' están adentro de la clase. 

Lo que es raro en ese ejemplo es como estamos usando la clase. En realidad el uso normal de una clase es para generar objetos, como es regla en la POO. Es más, como ya estamos metiéndonos en ese mundillo, adoptemos dos términos que son de uso genérico allí y que vamos a encontrar en muchos textos. Las variables dentro de las clases y objetos las llamaremos ``atributos'', mientras que las funciones que definimos allí adentro las llamaremos ``métodos''. Entonces, de acuerdo con esta nueva terminología, diremos que tenemos ``una clase Foo con un atributo a y un método f''.

Ahora hagamos el último salto y armemos una clase que tiene sentido ser usada para instanciar objetos.

\jupynotex[5]{Chapters/intro/code/encap-clases.ipynb}

Epa, ¡cuantas cosas nuevas! Vayamos entendiéndolas por partes, viendo cómo encaja en este uso distinto que mencionamos arriba. 

Las clases, en el paradigma de POO, son las estructuras que encapsulan el código para procesar determinada información, junto a dicha información. Y funcionan como plantillas, que nos darán distintos objetos cada vez que \textit{instanciemos} la clase. Estos objetos serán del mismo tipo (el tipo de los objetos es la clase en sí), y por lo tanto el código encapsulado será el mismo, aunque ese código procesará la distinta información que tendremos en cada objeto.

En nuestro ejemplo tenemos una clase TriánguloRectángulo, donde encapsulamos un código (cómo calcular la hipotenusa a partir de los catetos) junto a la información en sí (los catetos). Si queremos trabajar con distintos triángulos, obviamente tendremos una variedad de pares de catetos, pero en todos los casos la forma de calcular la hipotenusa es la misma; esto está en linea con la filosofía de la POO de que estos objetos modelan y representan nuestra realidad.

Armemos entonces dos triángulos, para experimentar y seguir entendiendo ese código (sin repetir aquí la definición de la clase, por brevedad):

\jupynotex[6-9]{Chapters/intro/code/encap-clases.ipynb}

Vemos que al nombre de la clase le estamos agregando paréntesis, como hacemos con las funciones cuando las ejecutamos. Aquí es similar, pero a la clase la estamos \textit{instanciando}, lo que nos devuelve un ``objeto del tipo TriánguloRectángulo'', que guardamos en t1 (y luego hacemos lo mismo con t2).

Cuando le decimos al intérprete interactivo que nos muestre esos objetos, vemos que nos dice que son del tipo TriánguloRectángulo y nos dice que están en posiciones de memoria distintas (con lo cual podemos deducir que son dos objetos distintos). Es más, cuando nos fijamos el valor de \verb|cateto1| de ambos objetos vemos que obtenemos distintos valores (¡son distintos objetos!), cada uno teniendo el primer valor que pasamos cuando instanciamos la clase. 

¿Cómo sucedió eso? Si volvemos a la definición de la clase, vemos que allí teníamos un método con un nombre especial, \mip{__init__}. Este método se ejecuta automáticamente cuando instanciamos la clase donde está definido. Entonces, cuando hicimos \mip{TriánguloRectángulo(4, 5)} se instanció la clase y se ejecutó ese método de inicialización, pasándole justamente estos valores que indicamos nosotros.

\begin{info}
Los métodos especiales son un conjunto de métodos predefinidos, con comportamientos específicos definidos en el lenguaje mismo \cite{metodos_especiales}, que Python utiliza para interactuar con los objetos en todo nivel, por ejemplo llamando a \mip{__init__} para inicializar una clase, o \mip{__iter__} cuando recorremos un objeto con el {for}.
\end{info}

Pero si prestamos un poco más de atención veremos que en su definición \mip{__init__} declara que tiene que recibir 3 parámetros (\verb|self|, \verb|cateto1| y \verb|cateto2|), mientras que nosotros estamos pasando solamente dos. Es que para todo lo que es métodos en las clases, Python inserta automáticamente como primer parámetro al objeto mismo que estamos manejando, al que por convención llamamos \mip{self}.

Y allí vemos que el cuerpo del método \mip{__init__} lo que hace es crear los nombres \verb|cateto1| y \verb|cateto2| \textit{adentro del objeto}, apuntando a los objetos recibidos. Entonces, cuando instanciamos TriánguloRectángulo la primera vez, pasamos los valores 4 y 5 y en ese caso el \mip{self} es el objeto que terminamos llamando t1 y guarda esos dos valores, y cuando la instanciamos por segunda vez, pasando los valores 10 y 1, \mip{self} es el objeto que terminamos llamando t2, con estos dos otros valores en vez.

Usemos ahora el otro método que tenemos definido:

\jupynotex[10-11]{Chapters/intro/code/encap-clases.ipynb}

Vemos que lo ejecutamos desde t1 y t2, y no pasamos ningún parámetro. Pero en la definición, arriba en la clase, recibe el parámetro \mip{self}. Estamos en la misma situación que antes: como es el método de una clase, cuando lo ejecutamos desde una instancia de la clase Python insertará el objeto mismo como parámetro, que oportunamente usamos para la cuenta: cuando hacemos por ejemplo \mip{self.cateto1 ** 2} estamos usando el nombre \verb|cateto1| de adentro del objeto, que para t1 apuntará a 4 y para t2 apuntará a 10. 

Al final de cuentas, lo que tenemos es un determinado código que se aplica a los valores que tiene cada instancia de esa clase. Exactamente el concepto con el que arrancamos arriba toda la explicación de clases, objetos, y POO.

Otro concepto muy útil cuando queremos modelar la realidad usando objetos es el de ``herencia'', generalmente utilizado cuando tenemos algunos comportamientos que son comunes a distintos tipos de objetos. Lo normal es encontrar una clase ``padre'' y muchas clases ``hijas'', pero Python soporta herencia múltiple, aunque es de uso más raro.

Cuando definimos una clase, entonces, si queremos que herede de otra incluiremos a esta última entre paréntesis en la definición de la primera. No vamos a entrar en detalle en este libro sobre cómo explotar todas las características del concepto de herencia, pero lo mencionamos para poder reconocer su uso cuando lo encontremos en algún código.

Particularmente, un caso que incluso ya mostramos en la Sección \ref{sub:excepciones} es cuando creamos una excepción propia, que para que sea justamente una excepción utilizable por el lenguaje, la definimos heredando su comportamiento de alguna excepción integrada en el lenguaje:

\jupynotex[12]{Chapters/intro/code/encap-clases.ipynb}


\subsection{Módulos}\label{sub:modulos}

Como vimos hasta ahora, las formas más comunes de encapsular código son las funciones y las clases. Entonces, pondremos código adentro de esas estructuras, que usaremos desde distintos puntos de nuestro programa. El paso natural siguiente es el de agrupar algunas de esas funciones y clases de nuestro programa en \textit{módulos}, de manera de poder importar esos módulos de distintos lugares y tener acceso a las funciones y clases (y cualquier otra estructura) que pongamos allí.

Los módulos no son más que archivos de Python, sin tener casi ninguna otra restricción. Mostremos un ejemplo para ver lo sencillo que es crear y usar un nuevo módulo de Python.

Pongamos el siguiente código en un archivo, al que llamaremos \texttt{perimetros.py}:

\pyfile{Chapters/intro/code/perimetros.py}

Vemos en el ejemplo que además de la definición de esas funciones tenemos otras líneas de código a ``nivel de módulo'', como el \mip{import} o el cálculo para tener ``dos $\pi$'' a mano. Todo el código del módulo se ejecutará cuando lo importemos; se importará math, se definirá \texttt{dos\_pi}, y también se definirán las dos funciones que usaremos luego.

Para usar ese módulo, como es el caso con cualquier otro módulo, sólo tenemos que importarlo. Entonces, en el mismo directorio que grabamos \texttt{perimetros.py}, abramos un intérprete interactivo y hagamos:

\begin{py}  
>>> import perimetros
>>> perimetros.círculo(12)
75.39822368615503
\end{py}

Necesitamos que el módulo esté en el mismo directorio donde abrimos el intérprete interactivo porque cuando hacemos el \mip{import} Python va a buscar el nombre que indicamos en una serie de directorios, entre ellos el actual del proceso. Claro, podríamos poner nuestro módulo en algunos de los otros directorios donde Python busca, pero ello ya implicaría \textit{instalar} nuestro módulo.

La otra opción para facilitar que podamos encontrar nuestro módulo es directamente agregar el directorio que necesitemos en la lista de lugares donde Python busca. Esto lo podemos hacer a través de la variable de entorno \texttt{PYTHONPATH} del sistema operativo, o incluso desde adentro de Python modificando \mip{sys.path}.

Volviendo al ejemplo donde usamos nuestro módulo, vemos que lo importamos usando su nombre, y luego podemos acceder a su contenido usando el \mip{.}, como ya vimos en otros casos. Esta no es la única manera de importar el módulo, también podemos utilizar otra forma en la que en vez de quedarnos con el nombre del módulo para trabajar, nos traemos directamente los nombres de las estructuras internas:

\begin{py}  
>>> from perimetros import círculo
>>> círculo(12)
75.39822368615503
\end{py}

Tengamos en cuenta que no cambia nada a la hora de importar el módulo en sí, no es más rápido, ni usa menos memoria, ni ejecuta menos código: la única diferencia es con qué nombres nos quedamos para trabajar.

Bien, ya sabemos agrupar nuestro código en módulos. El próximo paso es agrupar esos módulos en un próximo nivel.

La estructura para agrupar módulos se llama \textit{paquete}, que no son más que directorios.

Para probar esto, creemos un directorio \texttt{geom} y pongamos nuestro archivo \texttt{perimetros.py} allí. Eso es todo; ahora para importar ese módulo tenemos que especificar el paquete. Veamos las distintas formas de terminar ejecutando la función \texttt{círculo} en esta nueva situación: indicando el paquete y el módulo, trayendo el módulo del paquete, y trayendo directamente la función (de nuevo, en los tres casos el módulo se importa exactamente igual, sólo cambia con qué nos quedamos para trabajar).

\begin{py}  
>>> import geom.perimetros
>>> geom.perimetros.círculo(12)
75.39822368615503
>>> from geom import perimetros
>>> perimetros.círculo(12)
75.39822368615503
>>> from geom.perimetros import círculo
>>> círculo(12)
75.39822368615503
\end{py}

Si en un directorio/paquete ponemos un archivo con el nombre especial \texttt{\_\_init\_\_.py}, este archivo se ejecutará cuando importemos el paquete o cualquier módulo de ese paquete, lo cual es muy práctico para cualquier tipo de inicialización que necesitemos realizar.


\section{Cómo pedir ayuda}

Una de las grandes cosas buenas de Python es su Comunidad, alrededor del mundo y en infinidad de idiomas.

Siempre vamos a encontrar un foro, una lista de correo, o algún recurso gratuito puesto a disposición por gente tratando de ayudar. Y la misma comunidad se autorregula para seguir siendo sana, tanto informalmente como formalmente, por ejemplo creando la Python Software Foundation en Estados Unidos, o la Asociación Civil Python Argentina \cite{asoc_civil_pyar}, organizaciones que aprueban y alientan la participación de todes. Nuestra comunidad esta basada en respeto mutuo, tolerancia y fomento, y estamos trabajando para ayudar a cada uno y a cada una a vivir a la altura de estos principios. Queremos que la comunidad sea más diversa \cite{diversidad}: quien quieras que seas, y cualquiera sean tus orígenes, te recibiremos.

Los canales de comunicación virtuales son el principal medio de comunicación e integración de la Comunidad, y es un buen punto de entrada para cuando tenemos consultas y preguntas. Aprender a utilizar estos mecanismos es un activo tan importante en un programador o una desarrolladora de software como saber tal función, tal estructura del lenguaje, o tal detalle de implementación.

Es por esto que queremos hacer mucho énfasis en que busquen como interactuar con la Comunidad, cuales grupos de usuaries tienen cerca, qué lista de correo o foro les apetece más, y empiecen a participar allí. Si ya tienen consultas pueden hacerlas, pero también es muy valioso leer las preguntas de otres y las respuestas que se ofrecen, e incluso tratar de responderlas nosotres. Esta es una de las mejores formas de profundizar nuestro conocimiento en Python.

Te recomendamos explorar el sitio de Python Argentina \cite{pyar}, o entrar directamente en su grupo de Telegram \cite{pyar_telegram} o en el foro \cite{pyar_foro}. Pero no dejes de de revisar si hay alguna comunidad local más cerca de donde estés \cite{python_lugs}.

Y siempre está la comunidad global de Python, con muchísimos recursos en su sitio \cite{python_org}, en particular las listas de correo \cite{python_lists} y el foro \cite{python_forum}, pero claro, esto es todo en inglés.
